# 1 "sysc/sdldrawlib.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "sysc/sdldrawlib.c"
# 32 "sysc/sdldrawlib.c"
# 1 "sysc/sdldraw.h" 1
# 27 "sysc/sdldraw.h"
# 1 "/usr/local/include/SDL/SDL.h" 1 3
# 30 "/usr/local/include/SDL/SDL.h" 3
# 1 "/usr/local/include/SDL/SDL_main.h" 1 3
# 26 "/usr/local/include/SDL/SDL_main.h" 3
# 1 "/usr/local/include/SDL/SDL_stdinc.h" 1 3
# 30 "/usr/local/include/SDL/SDL_stdinc.h" 3
# 1 "/usr/local/include/SDL/SDL_config.h" 1 3
# 30 "/usr/local/include/SDL/SDL_config.h" 3
# 1 "/usr/local/include/SDL/SDL_platform.h" 1 3
# 31 "/usr/local/include/SDL/SDL_config.h" 2 3
# 31 "/usr/local/include/SDL/SDL_stdinc.h" 2 3



# 1 "/usr/include/i386-linux-gnu/sys/types.h" 1 3 4
# 26 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 324 "/usr/include/features.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/predefs.h" 1 3 4
# 325 "/usr/include/features.h" 2 3 4
# 357 "/usr/include/features.h" 3 4
# 1 "/usr/include/i386-linux-gnu/sys/cdefs.h" 1 3 4
# 378 "/usr/include/i386-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 379 "/usr/include/i386-linux-gnu/sys/cdefs.h" 2 3 4
# 358 "/usr/include/features.h" 2 3 4
# 389 "/usr/include/features.h" 3 4
# 1 "/usr/include/i386-linux-gnu/gnu/stubs.h" 1 3 4



# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/i386-linux-gnu/gnu/stubs.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/i386-linux-gnu/gnu/stubs.h" 2 3 4
# 390 "/usr/include/features.h" 2 3 4
# 27 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4



# 1 "/usr/include/i386-linux-gnu/bits/types.h" 1 3 4
# 28 "/usr/include/i386-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/i386-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 131 "/usr/include/i386-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/typesizes.h" 1 3 4
# 132 "/usr/include/i386-linux-gnu/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 31 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 3 4
typedef unsigned int size_t;
# 148 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 217 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/byteswap.h" 1 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 218 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/sys/select.h" 1 3 4
# 31 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/select.h" 1 3 4
# 32 "/usr/include/i386-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/bits/sigset.h" 1 3 4
# 24 "/usr/include/i386-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/i386-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/usr/include/i386-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/i386-linux-gnu/bits/time.h" 1 3 4
# 31 "/usr/include/i386-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/i386-linux-gnu/sys/select.h" 2 3 4
# 55 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 65 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 97 "/usr/include/i386-linux-gnu/sys/select.h" 3 4

# 107 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 119 "/usr/include/i386-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);





# 1 "/usr/include/i386-linux-gnu/bits/select2.h" 1 3 4
# 25 "/usr/include/i386-linux-gnu/bits/select2.h" 3 4
extern unsigned long int __fdelt_chk (unsigned long int __d);
extern unsigned long int __fdelt_warn (unsigned long int __d)
  __attribute__((__warning__ ("bit outside of fd_set selected")));
# 130 "/usr/include/i386-linux-gnu/sys/select.h" 2 3 4



# 221 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/i386-linux-gnu/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}


# 224 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 263 "/usr/include/i386-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/i386-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 36 "/usr/include/i386-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;


typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 272 "/usr/include/i386-linux-gnu/sys/types.h" 2 3 4



# 35 "/usr/local/include/SDL/SDL_stdinc.h" 2 3


# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 172 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 182 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 205 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 273 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 321 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 330 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 366 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 462 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 492 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 109 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 165 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/stdio_lim.h" 1 3 4
# 166 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
# 206 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) __attribute__ ((__warn_unused_result__));



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 228 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 253 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 263 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 296 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
# 418 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (__const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 469 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 528 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 556 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 567 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 600 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));






extern char *gets (char *__s) __attribute__ ((__warn_unused_result__));

# 646 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 662 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 723 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 734 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);

# 770 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
# 789 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 812 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));








extern void perror (__const char *__s);






# 1 "/usr/include/i386-linux-gnu/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/i386-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 851 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 870 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 931 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/stdio.h" 1 3 4
# 44 "/usr/include/i386-linux-gnu/bits/stdio.h" 3 4
extern __inline int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 932 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/bits/stdio2.h" 1 3 4
# 24 "/usr/include/i386-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      __const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, __const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, __const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, __const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, __const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, __const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     __const char *__restrict __format, ...);
extern int __printf_chk (int __flag, __const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      __const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, __const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, __const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
printf (__const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   __const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}



extern int __asprintf_chk (char **__restrict __ptr, int __flag,
      __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__warn_unused_result__));
extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
       __const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 0))) __attribute__ ((__warn_unused_result__));
extern int __dprintf_chk (int __fd, int __flag, __const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      __const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));
extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
     int __flag, __const char *__restrict __format,
     ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
      int __flag,
      __const char *__restrict __format,
      __gnuc_va_list __args)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...)
{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) __asprintf (char **__restrict __ptr, __const char *__restrict __fmt, ...)

{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
dprintf (int __fd, __const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) obstack_printf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, ...)

{
  return __obstack_printf_chk (__obstack, 2 - 1, __fmt,
          __builtin_va_arg_pack ());
}
# 195 "/usr/include/i386-linux-gnu/bits/stdio2.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vasprintf (char **__restrict __ptr, __const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __vasprintf_chk (__ptr, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
vdprintf (int __fd, __const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) obstack_vprintf (struct obstack *__restrict __obstack, __const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __obstack_vprintf_chk (__obstack, 2 - 1, __fmt,
    __ap);
}





extern char *__gets_chk (char *__str, size_t) __attribute__ ((__warn_unused_result__));
extern char *__gets_warn (char *__str) __asm__ ("" "gets")
     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use fgets or getline instead, gets can't " "specify buffer size")))
                               ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
gets (char *__str)
{
  if (__builtin_object_size (__str, 2 > 1) != (size_t) -1)
    return __gets_chk (__str, __builtin_object_size (__str, 2 > 1));
  return __gets_warn (__str);
}

extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")

                                        __attribute__ ((__warn_unused_result__));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}


extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
       int __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked")

                                                 __attribute__ ((__warn_unused_result__));
extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_unlocked_alias (__s, __n, __stream);
}




extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")


                     __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
                                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
         __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
       __stream);
    }


  if (__builtin_constant_p (__size)
      && __builtin_constant_p (__n)
      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
      && __size * __n <= 8)
    {
      size_t __cnt = __size * __n;
      char *__cptr = (char *) __ptr;
      if (__cnt == 0)
 return 0;

      for (; __cnt > 0; --__cnt)
 {
   int __c = (__builtin_expect (((__stream)->_IO_read_ptr >= (__stream)->_IO_read_end), 0) ? __uflow (__stream) : *(unsigned char *) (__stream)->_IO_read_ptr++);
   if (__c == (-1))
     break;
   *__cptr++ = __c;
 }
      return (__cptr - (char *) __ptr) / __size;
    }

  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}
# 935 "/usr/include/stdio.h" 2 3 4






# 38 "/usr/local/include/SDL/SDL_stdinc.h" 2 3


# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 324 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 3 4
typedef int wchar_t;
# 34 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/i386-linux-gnu/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/i386-linux-gnu/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/i386-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 68 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

# 236 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 237 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4))) __attribute__ ((__warn_unused_result__));

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));





extern __inline double
__attribute__ ((__nothrow__ , __leaf__)) atof (__const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) atoi (__const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline long int
__attribute__ ((__nothrow__ , __leaf__)) atol (__const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}




__extension__ extern __inline long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (__const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}

# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 327 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 498 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 528 "/usr/include/stdlib.h" 3 4
extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));







extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));









extern int system (__const char *__command) __attribute__ ((__warn_unused_result__));






extern char *canonicalize_file_name (__const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));

# 808 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 896 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));





extern void setkey (__const char *__key) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





# 1 "/usr/include/i386-linux-gnu/bits/stdlib.h" 1 3 4
# 24 "/usr/include/i386-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (__const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (__const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ , __leaf__))

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (__const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ , __leaf__))


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (__const char *__restrict __name, char *__restrict __resolved)
{
  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
    {




      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ , __leaf__))
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         __const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __dst, __const char *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         __const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __wcstombs_alias (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __wcstombs_chk_warn (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, __const wchar_t *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 956 "/usr/include/stdlib.h" 2 3 4
# 964 "/usr/include/stdlib.h" 3 4

# 41 "/usr/local/include/SDL/SDL_stdinc.h" 2 3
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 150 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 42 "/usr/local/include/SDL/SDL_stdinc.h" 2 3
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stdarg.h" 1 3 4
# 43 "/usr/local/include/SDL/SDL_stdinc.h" 2 3
# 60 "/usr/local/include/SDL/SDL_stdinc.h" 3
# 1 "/usr/include/string.h" 1 3 4
# 29 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 35 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 95 "/usr/include/string.h" 3 4
extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 109 "/usr/include/string.h" 3 4
extern void *rawmemchr (__const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 120 "/usr/include/string.h" 3 4
extern void *memrchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 165 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 210 "/usr/include/string.h" 3 4

# 235 "/usr/include/string.h" 3 4
extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 262 "/usr/include/string.h" 3 4
extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 276 "/usr/include/string.h" 3 4
extern char *strchrnul (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 314 "/usr/include/string.h" 3 4
extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 373 "/usr/include/string.h" 3 4
extern char *strcasestr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 606 "/usr/include/string.h" 3 4
extern char *basename (__const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 634 "/usr/include/string.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/string.h" 1 3 4
# 635 "/usr/include/string.h" 2 3 4


# 1 "/usr/include/i386-linux-gnu/bits/string2.h" 1 3 4
# 394 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern void *__rawmemchr (const void *__s, int __c);
# 969 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern __inline size_t __strcspn_c1 (__const char *__s, int __reject);
extern __inline size_t
__strcspn_c1 (__const char *__s, int __reject)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c2 (__const char *__s, int __reject1,
         int __reject2);
extern __inline size_t
__strcspn_c2 (__const char *__s, int __reject1, int __reject2)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c3 (__const char *__s, int __reject1,
         int __reject2, int __reject3);
extern __inline size_t
__strcspn_c3 (__const char *__s, int __reject1, int __reject2,
       int __reject3)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}
# 1045 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern __inline size_t __strspn_c1 (__const char *__s, int __accept);
extern __inline size_t
__strspn_c1 (__const char *__s, int __accept)
{
  register size_t __result = 0;

  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c2 (__const char *__s, int __accept1,
        int __accept2);
extern __inline size_t
__strspn_c2 (__const char *__s, int __accept1, int __accept2)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c3 (__const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline size_t
__strspn_c3 (__const char *__s, int __accept1, int __accept2, int __accept3)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2
  || __s[__result] == __accept3)
    ++__result;
  return __result;
}
# 1121 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern __inline char *__strpbrk_c2 (__const char *__s, int __accept1,
         int __accept2);
extern __inline char *
__strpbrk_c2 (__const char *__s, int __accept1, int __accept2)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}

extern __inline char *__strpbrk_c3 (__const char *__s, int __accept1,
         int __accept2, int __accept3);
extern __inline char *
__strpbrk_c3 (__const char *__s, int __accept1, int __accept2,
       int __accept3)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
  && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}
# 1172 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern __inline char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void *)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void *)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
    }
  *__nextp = __s;
  return __result;
}
# 1204 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern char *__strsep_g (char **__stringp, __const char *__delim);
# 1222 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern __inline char *__strsep_1c (char **__s, char __reject);
extern __inline char *
__strsep_1c (char **__s, char __reject)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void *)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}
# 1303 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern char *__strdup (__const char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
# 1322 "/usr/include/i386-linux-gnu/bits/string2.h" 3 4
extern char *__strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
# 638 "/usr/include/string.h" 2 3 4




# 1 "/usr/include/i386-linux-gnu/bits/string3.h" 1 3 4
# 23 "/usr/include/i386-linux-gnu/bits/string3.h" 3 4
extern void __warn_memset_zero_len (void) __attribute__((__warning__ ("memset used with constant zero length parameter; this could be due to transposed parameters")))
                                                                                                   ;
# 48 "/usr/include/i386-linux-gnu/bits/string3.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, __const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) mempcpy (void *__restrict __dest, __const void *__restrict __src, size_t __len)

{
  return __builtin___mempcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 76 "/usr/include/i386-linux-gnu/bits/string3.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, size_t __len)
{
  if (__builtin_constant_p (__len) && __len == 0
      && (!__builtin_constant_p (__ch) || __ch != 0))
    {
      __warn_memset_zero_len ();
      return __dest;
    }
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bcopy (__const void *__src, void *__dest, size_t __len)
{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bzero (void *__dest, size_t __len)
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, __const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpcpy (char *__restrict __dest, __const char *__restrict __src)
{
  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, __const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}


extern char *__stpncpy_chk (char *__dest, __const char *__src, size_t __n,
       size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern char *__stpncpy_alias (char *__dest, __const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__ , __leaf__))

                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, __const char *__src, size_t __n)
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n <= __builtin_object_size (__dest, 2 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, __const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, __const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
# 643 "/usr/include/string.h" 2 3 4




# 61 "/usr/local/include/SDL/SDL_stdinc.h" 2 3


# 1 "/usr/include/strings.h" 1 3 4
# 64 "/usr/local/include/SDL/SDL_stdinc.h" 2 3


# 1 "/usr/include/inttypes.h" 1 3 4
# 28 "/usr/include/inttypes.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stdint.h" 1 3 4


# 1 "/usr/include/stdint.h" 1 3 4
# 27 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wchar.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 126 "/usr/include/stdint.h" 3 4
typedef int intptr_t;


typedef unsigned int uintptr_t;
# 138 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 4 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stdint.h" 2 3 4
# 29 "/usr/include/inttypes.h" 2 3 4






typedef int __gwchar_t;
# 274 "/usr/include/inttypes.h" 3 4

# 288 "/usr/include/inttypes.h" 3 4
typedef struct
  {
    long long int quot;
    long long int rem;
  } imaxdiv_t;





extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (__const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (__const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (__const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 379 "/usr/include/inttypes.h" 3 4
__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline intmax_t
__attribute__ ((__nothrow__ , __leaf__)) strtoimax (__const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtoll_internal (nptr, endptr, base, 0);
}

__extension__
extern unsigned long long int __strtoull_internal (__const char *
         __restrict __nptr,
         char **
         __restrict __endptr,
         int __base,
         int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline uintmax_t
__attribute__ ((__nothrow__ , __leaf__)) strtoumax (__const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtoull_internal (nptr, endptr, base, 0);
}

__extension__
extern long long int __wcstoll_internal (__const __gwchar_t *
      __restrict __nptr,
      __gwchar_t **__restrict __endptr,
      int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline intmax_t
__attribute__ ((__nothrow__ , __leaf__)) wcstoimax (__const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstoll_internal (nptr, endptr, base, 0);
}


__extension__
extern unsigned long long int __wcstoull_internal (__const __gwchar_t *
         __restrict __nptr,
         __gwchar_t **
         __restrict __endptr,
         int __base,
         int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline uintmax_t
__attribute__ ((__nothrow__ , __leaf__)) wcstoumax (__const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstoull_internal (nptr, endptr, base, 0);
}





# 67 "/usr/local/include/SDL/SDL_stdinc.h" 2 3




# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4

# 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const));
# 106 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));








extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));






extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 216 "/usr/include/ctype.h" 3 4
extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 273 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 349 "/usr/include/ctype.h" 3 4

# 72 "/usr/local/include/SDL/SDL_stdinc.h" 2 3


# 1 "/usr/include/iconv.h" 1 3 4
# 24 "/usr/include/iconv.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 25 "/usr/include/iconv.h" 2 3 4





typedef void *iconv_t;







extern iconv_t iconv_open (__const char *__tocode, __const char *__fromcode);




extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);





extern int iconv_close (iconv_t __cd);


# 75 "/usr/local/include/SDL/SDL_stdinc.h" 2 3
# 93 "/usr/local/include/SDL/SDL_stdinc.h" 3
typedef enum {
 SDL_FALSE = 0,
 SDL_TRUE = 1
} SDL_bool;

typedef int8_t Sint8;
typedef uint8_t Uint8;
typedef int16_t Sint16;
typedef uint16_t Uint16;
typedef int32_t Sint32;
typedef uint32_t Uint32;


typedef int64_t Sint64;

typedef uint64_t Uint64;
# 125 "/usr/local/include/SDL/SDL_stdinc.h" 3
typedef int SDL_dummy_uint8[(sizeof(Uint8) == 1) * 2 - 1];
typedef int SDL_dummy_sint8[(sizeof(Sint8) == 1) * 2 - 1];
typedef int SDL_dummy_uint16[(sizeof(Uint16) == 2) * 2 - 1];
typedef int SDL_dummy_sint16[(sizeof(Sint16) == 2) * 2 - 1];
typedef int SDL_dummy_uint32[(sizeof(Uint32) == 4) * 2 - 1];
typedef int SDL_dummy_sint32[(sizeof(Sint32) == 4) * 2 - 1];
typedef int SDL_dummy_uint64[(sizeof(Uint64) == 8) * 2 - 1];
typedef int SDL_dummy_sint64[(sizeof(Sint64) == 8) * 2 - 1];
# 146 "/usr/local/include/SDL/SDL_stdinc.h" 3
typedef enum {
 DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;


typedef int SDL_dummy_enum[(sizeof(SDL_DUMMY_ENUM) == sizeof(int)) * 2 - 1];



# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 156 "/usr/local/include/SDL/SDL_stdinc.h" 2 3
# 403 "/usr/local/include/SDL/SDL_stdinc.h" 3
extern __attribute__ ((visibility("default"))) size_t SDL_strlcpy(char *dst, const char *src, size_t maxlen);





extern __attribute__ ((visibility("default"))) size_t SDL_strlcat(char *dst, const char *src, size_t maxlen);
# 421 "/usr/local/include/SDL/SDL_stdinc.h" 3
extern __attribute__ ((visibility("default"))) char * SDL_strrev(char *string);





extern __attribute__ ((visibility("default"))) char * SDL_strupr(char *string);





extern __attribute__ ((visibility("default"))) char * SDL_strlwr(char *string);
# 467 "/usr/local/include/SDL/SDL_stdinc.h" 3
extern __attribute__ ((visibility("default"))) char * SDL_ltoa(long value, char *string, int radix);
# 479 "/usr/local/include/SDL/SDL_stdinc.h" 3
extern __attribute__ ((visibility("default"))) char * SDL_ultoa(unsigned long value, char *string, int radix);
# 499 "/usr/local/include/SDL/SDL_stdinc.h" 3
extern __attribute__ ((visibility("default"))) char* SDL_lltoa(Sint64 value, char *string, int radix);





extern __attribute__ ((visibility("default"))) char* SDL_ulltoa(Uint64 value, char *string, int radix);
# 605 "/usr/local/include/SDL/SDL_stdinc.h" 3
extern __attribute__ ((visibility("default"))) size_t SDL_iconv(iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);



extern __attribute__ ((visibility("default"))) char * SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf, size_t inbytesleft);
# 618 "/usr/local/include/SDL/SDL_stdinc.h" 3
# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 619 "/usr/local/include/SDL/SDL_stdinc.h" 2 3
# 27 "/usr/local/include/SDL/SDL_main.h" 2 3
# 31 "/usr/local/include/SDL/SDL.h" 2 3

# 1 "/usr/local/include/SDL/SDL_audio.h" 1 3
# 32 "/usr/local/include/SDL/SDL_audio.h" 3
# 1 "/usr/local/include/SDL/SDL_error.h" 1 3
# 33 "/usr/local/include/SDL/SDL_error.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 34 "/usr/local/include/SDL/SDL_error.h" 2 3
# 43 "/usr/local/include/SDL/SDL_error.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetError(const char *fmt, ...);
extern __attribute__ ((visibility("default"))) char * SDL_GetError(void);
extern __attribute__ ((visibility("default"))) void SDL_ClearError(void);
# 55 "/usr/local/include/SDL/SDL_error.h" 3
typedef enum {
 SDL_ENOMEM,
 SDL_EFREAD,
 SDL_EFWRITE,
 SDL_EFSEEK,
 SDL_UNSUPPORTED,
 SDL_LASTERROR
} SDL_errorcode;
extern __attribute__ ((visibility("default"))) void SDL_Error(SDL_errorcode code);






# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 71 "/usr/local/include/SDL/SDL_error.h" 2 3
# 33 "/usr/local/include/SDL/SDL_audio.h" 2 3
# 1 "/usr/local/include/SDL/SDL_endian.h" 1 3
# 59 "/usr/local/include/SDL/SDL_endian.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 60 "/usr/local/include/SDL/SDL_endian.h" 2 3
# 75 "/usr/local/include/SDL/SDL_endian.h" 3
static __inline__ Uint16 SDL_Swap16(Uint16 x)
{
 __asm__("xchgb %b0,%h0" : "=q" (x) : "0" (x));
 return x;
}
# 108 "/usr/local/include/SDL/SDL_endian.h" 3
static __inline__ Uint32 SDL_Swap32(Uint32 x)
{
 __asm__("bswap %0" : "=r" (x) : "0" (x));
 return x;
}
# 144 "/usr/local/include/SDL/SDL_endian.h" 3
static __inline__ Uint64 SDL_Swap64(Uint64 x)
{
 union {
  struct { Uint32 a,b; } s;
  Uint64 u;
 } v;
 v.u = x;
 __asm__("bswapl %0 ; bswapl %1 ; xchgl %0,%1"
         : "=r" (v.s.a), "=r" (v.s.b)
         : "0" (v.s.a), "1" (v.s.b));
 return v.u;
}
# 212 "/usr/local/include/SDL/SDL_endian.h" 3
# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 213 "/usr/local/include/SDL/SDL_endian.h" 2 3
# 34 "/usr/local/include/SDL/SDL_audio.h" 2 3
# 1 "/usr/local/include/SDL/SDL_mutex.h" 1 3
# 35 "/usr/local/include/SDL/SDL_mutex.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 36 "/usr/local/include/SDL/SDL_mutex.h" 2 3
# 55 "/usr/local/include/SDL/SDL_mutex.h" 3
struct SDL_mutex;
typedef struct SDL_mutex SDL_mutex;


extern __attribute__ ((visibility("default"))) SDL_mutex * SDL_CreateMutex(void);





extern __attribute__ ((visibility("default"))) int SDL_mutexP(SDL_mutex *mutex);
# 74 "/usr/local/include/SDL/SDL_mutex.h" 3
extern __attribute__ ((visibility("default"))) int SDL_mutexV(SDL_mutex *mutex);


extern __attribute__ ((visibility("default"))) void SDL_DestroyMutex(SDL_mutex *mutex);
# 86 "/usr/local/include/SDL/SDL_mutex.h" 3
struct SDL_semaphore;
typedef struct SDL_semaphore SDL_sem;


extern __attribute__ ((visibility("default"))) SDL_sem * SDL_CreateSemaphore(Uint32 initial_value);


extern __attribute__ ((visibility("default"))) void SDL_DestroySemaphore(SDL_sem *sem);






extern __attribute__ ((visibility("default"))) int SDL_SemWait(SDL_sem *sem);





extern __attribute__ ((visibility("default"))) int SDL_SemTryWait(SDL_sem *sem);
# 115 "/usr/local/include/SDL/SDL_mutex.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 ms);




extern __attribute__ ((visibility("default"))) int SDL_SemPost(SDL_sem *sem);


extern __attribute__ ((visibility("default"))) Uint32 SDL_SemValue(SDL_sem *sem);
# 133 "/usr/local/include/SDL/SDL_mutex.h" 3
struct SDL_cond;
typedef struct SDL_cond SDL_cond;



extern __attribute__ ((visibility("default"))) SDL_cond * SDL_CreateCond(void);


extern __attribute__ ((visibility("default"))) void SDL_DestroyCond(SDL_cond *cond);




extern __attribute__ ((visibility("default"))) int SDL_CondSignal(SDL_cond *cond);




extern __attribute__ ((visibility("default"))) int SDL_CondBroadcast(SDL_cond *cond);






extern __attribute__ ((visibility("default"))) int SDL_CondWait(SDL_cond *cond, SDL_mutex *mut);







extern __attribute__ ((visibility("default"))) int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms);







# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 175 "/usr/local/include/SDL/SDL_mutex.h" 2 3
# 35 "/usr/local/include/SDL/SDL_audio.h" 2 3
# 1 "/usr/local/include/SDL/SDL_thread.h" 1 3
# 38 "/usr/local/include/SDL/SDL_thread.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 39 "/usr/local/include/SDL/SDL_thread.h" 2 3






struct SDL_Thread;
typedef struct SDL_Thread SDL_Thread;
# 88 "/usr/local/include/SDL/SDL_thread.h" 3
extern __attribute__ ((visibility("default"))) SDL_Thread * SDL_CreateThread(int ( *fn)(void *), void *data);



extern __attribute__ ((visibility("default"))) Uint32 SDL_ThreadID(void);




extern __attribute__ ((visibility("default"))) Uint32 SDL_GetThreadID(SDL_Thread *thread);





extern __attribute__ ((visibility("default"))) void SDL_WaitThread(SDL_Thread *thread, int *status);


extern __attribute__ ((visibility("default"))) void SDL_KillThread(SDL_Thread *thread);






# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 114 "/usr/local/include/SDL/SDL_thread.h" 2 3
# 36 "/usr/local/include/SDL/SDL_audio.h" 2 3
# 1 "/usr/local/include/SDL/SDL_rwops.h" 1 3
# 34 "/usr/local/include/SDL/SDL_rwops.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 35 "/usr/local/include/SDL/SDL_rwops.h" 2 3







typedef struct SDL_RWops {




 int ( *seek)(struct SDL_RWops *context, int offset, int whence);





 int ( *read)(struct SDL_RWops *context, void *ptr, int size, int maxnum);





 int ( *write)(struct SDL_RWops *context, const void *ptr, int size, int num);


 int ( *close)(struct SDL_RWops *context);

 Uint32 type;
 union {
# 78 "/usr/local/include/SDL/SDL_rwops.h" 3
     struct {
  int autoclose;
   FILE *fp;
     } stdio;

     struct {
  Uint8 *base;
   Uint8 *here;
  Uint8 *stop;
     } mem;
     struct {
  void *data1;
     } unknown;
 } hidden;

} SDL_RWops;





extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromFile(const char *file, const char *mode);


extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromFP(FILE *fp, int autoclose);


extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromMem(void *mem, int size);
extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_RWFromConstMem(const void *mem, int size);

extern __attribute__ ((visibility("default"))) SDL_RWops * SDL_AllocRW(void);
extern __attribute__ ((visibility("default"))) void SDL_FreeRW(SDL_RWops *area);
# 131 "/usr/local/include/SDL/SDL_rwops.h" 3
extern __attribute__ ((visibility("default"))) Uint16 SDL_ReadLE16(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) Uint16 SDL_ReadBE16(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) Uint32 SDL_ReadLE32(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) Uint32 SDL_ReadBE32(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) Uint64 SDL_ReadLE64(SDL_RWops *src);
extern __attribute__ ((visibility("default"))) Uint64 SDL_ReadBE64(SDL_RWops *src);




extern __attribute__ ((visibility("default"))) int SDL_WriteLE16(SDL_RWops *dst, Uint16 value);
extern __attribute__ ((visibility("default"))) int SDL_WriteBE16(SDL_RWops *dst, Uint16 value);
extern __attribute__ ((visibility("default"))) int SDL_WriteLE32(SDL_RWops *dst, Uint32 value);
extern __attribute__ ((visibility("default"))) int SDL_WriteBE32(SDL_RWops *dst, Uint32 value);
extern __attribute__ ((visibility("default"))) int SDL_WriteLE64(SDL_RWops *dst, Uint64 value);
extern __attribute__ ((visibility("default"))) int SDL_WriteBE64(SDL_RWops *dst, Uint64 value);






# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 154 "/usr/local/include/SDL/SDL_rwops.h" 2 3
# 37 "/usr/local/include/SDL/SDL_audio.h" 2 3

# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 39 "/usr/local/include/SDL/SDL_audio.h" 2 3
# 74 "/usr/local/include/SDL/SDL_audio.h" 3
typedef struct SDL_AudioSpec {
 int freq;
 Uint16 format;
 Uint8 channels;
 Uint8 silence;
 Uint16 samples;
 Uint16 padding;
 Uint32 size;
# 91 "/usr/local/include/SDL/SDL_audio.h" 3
 void ( *callback)(void *userdata, Uint8 *stream, int len);
 void *userdata;
} SDL_AudioSpec;
# 126 "/usr/local/include/SDL/SDL_audio.h" 3
typedef struct SDL_AudioCVT {
 int needed;
 Uint16 src_format;
 Uint16 dst_format;
 double rate_incr;
 Uint8 *buf;
 int len;
 int len_cvt;
 int len_mult;
 double len_ratio;
 void ( *filters[10])(struct SDL_AudioCVT *cvt, Uint16 format);
 int filter_index;
} SDL_AudioCVT;
# 150 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_AudioInit(const char *driver_name);
extern __attribute__ ((visibility("default"))) void SDL_AudioQuit(void);







extern __attribute__ ((visibility("default"))) char * SDL_AudioDriverName(char *namebuf, int maxlen);
# 178 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained);

typedef enum {
 SDL_AUDIO_STOPPED = 0,
 SDL_AUDIO_PLAYING,
 SDL_AUDIO_PAUSED
} SDL_audiostatus;


extern __attribute__ ((visibility("default"))) SDL_audiostatus SDL_GetAudioStatus(void);
# 196 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_PauseAudio(int pause_on);
# 215 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) SDL_AudioSpec * SDL_LoadWAV_RW(SDL_RWops *src, int freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
# 224 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_FreeWAV(Uint8 *audio_buf);
# 234 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
  Uint16 src_format, Uint8 src_channels, int src_rate,
  Uint16 dst_format, Uint8 dst_channels, int dst_rate);
# 247 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) int SDL_ConvertAudio(SDL_AudioCVT *cvt);
# 258 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_MixAudio(Uint8 *dst, const Uint8 *src, Uint32 len, int volume);
# 268 "/usr/local/include/SDL/SDL_audio.h" 3
extern __attribute__ ((visibility("default"))) void SDL_LockAudio(void);
extern __attribute__ ((visibility("default"))) void SDL_UnlockAudio(void);





extern __attribute__ ((visibility("default"))) void SDL_CloseAudio(void);






# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 283 "/usr/local/include/SDL/SDL_audio.h" 2 3
# 33 "/usr/local/include/SDL/SDL.h" 2 3
# 1 "/usr/local/include/SDL/SDL_cdrom.h" 1 3
# 34 "/usr/local/include/SDL/SDL_cdrom.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 35 "/usr/local/include/SDL/SDL_cdrom.h" 2 3
# 59 "/usr/local/include/SDL/SDL_cdrom.h" 3
typedef enum {
 CD_TRAYEMPTY,
 CD_STOPPED,
 CD_PLAYING,
 CD_PAUSED,
 CD_ERROR = -1
} CDstatus;




typedef struct SDL_CDtrack {
 Uint8 id;
 Uint8 type;
 Uint16 unused;
 Uint32 length;
 Uint32 offset;
} SDL_CDtrack;


typedef struct SDL_CD {
 int id;
 CDstatus status;



 int numtracks;
 int cur_track;
 int cur_frame;
 SDL_CDtrack track[99 +1];

} SDL_CD;
# 114 "/usr/local/include/SDL/SDL_cdrom.h" 3
extern __attribute__ ((visibility("default"))) int SDL_CDNumDrives(void);
# 123 "/usr/local/include/SDL/SDL_cdrom.h" 3
extern __attribute__ ((visibility("default"))) const char * SDL_CDName(int drive);
# 132 "/usr/local/include/SDL/SDL_cdrom.h" 3
extern __attribute__ ((visibility("default"))) SDL_CD * SDL_CDOpen(int drive);






extern __attribute__ ((visibility("default"))) CDstatus SDL_CDStatus(SDL_CD *cdrom);
# 163 "/usr/local/include/SDL/SDL_cdrom.h" 3
extern __attribute__ ((visibility("default"))) int SDL_CDPlayTracks(SDL_CD *cdrom,
  int start_track, int start_frame, int ntracks, int nframes);





extern __attribute__ ((visibility("default"))) int SDL_CDPlay(SDL_CD *cdrom, int start, int length);




extern __attribute__ ((visibility("default"))) int SDL_CDPause(SDL_CD *cdrom);




extern __attribute__ ((visibility("default"))) int SDL_CDResume(SDL_CD *cdrom);




extern __attribute__ ((visibility("default"))) int SDL_CDStop(SDL_CD *cdrom);




extern __attribute__ ((visibility("default"))) int SDL_CDEject(SDL_CD *cdrom);


extern __attribute__ ((visibility("default"))) void SDL_CDClose(SDL_CD *cdrom);






# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 201 "/usr/local/include/SDL/SDL_cdrom.h" 2 3
# 34 "/usr/local/include/SDL/SDL.h" 2 3
# 1 "/usr/local/include/SDL/SDL_cpuinfo.h" 1 3
# 33 "/usr/local/include/SDL/SDL_cpuinfo.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 34 "/usr/local/include/SDL/SDL_cpuinfo.h" 2 3






extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasRDTSC(void);


extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasMMX(void);


extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasMMXExt(void);


extern __attribute__ ((visibility("default"))) SDL_bool SDL_Has3DNow(void);


extern __attribute__ ((visibility("default"))) SDL_bool SDL_Has3DNowExt(void);


extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE(void);


extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasSSE2(void);


extern __attribute__ ((visibility("default"))) SDL_bool SDL_HasAltiVec(void);





# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 68 "/usr/local/include/SDL/SDL_cpuinfo.h" 2 3
# 35 "/usr/local/include/SDL/SDL.h" 2 3


# 1 "/usr/local/include/SDL/SDL_events.h" 1 3
# 33 "/usr/local/include/SDL/SDL_events.h" 3
# 1 "/usr/local/include/SDL/SDL_active.h" 1 3
# 34 "/usr/local/include/SDL/SDL_active.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 35 "/usr/local/include/SDL/SDL_active.h" 2 3
# 54 "/usr/local/include/SDL/SDL_active.h" 3
extern __attribute__ ((visibility("default"))) Uint8 SDL_GetAppState(void);






# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 62 "/usr/local/include/SDL/SDL_active.h" 2 3
# 34 "/usr/local/include/SDL/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL/SDL_keyboard.h" 1 3
# 32 "/usr/local/include/SDL/SDL_keyboard.h" 3
# 1 "/usr/local/include/SDL/SDL_keysym.h" 1 3
# 31 "/usr/local/include/SDL/SDL_keysym.h" 3
typedef enum {




 SDLK_UNKNOWN = 0,
 SDLK_FIRST = 0,
 SDLK_BACKSPACE = 8,
 SDLK_TAB = 9,
 SDLK_CLEAR = 12,
 SDLK_RETURN = 13,
 SDLK_PAUSE = 19,
 SDLK_ESCAPE = 27,
 SDLK_SPACE = 32,
 SDLK_EXCLAIM = 33,
 SDLK_QUOTEDBL = 34,
 SDLK_HASH = 35,
 SDLK_DOLLAR = 36,
 SDLK_AMPERSAND = 38,
 SDLK_QUOTE = 39,
 SDLK_LEFTPAREN = 40,
 SDLK_RIGHTPAREN = 41,
 SDLK_ASTERISK = 42,
 SDLK_PLUS = 43,
 SDLK_COMMA = 44,
 SDLK_MINUS = 45,
 SDLK_PERIOD = 46,
 SDLK_SLASH = 47,
 SDLK_0 = 48,
 SDLK_1 = 49,
 SDLK_2 = 50,
 SDLK_3 = 51,
 SDLK_4 = 52,
 SDLK_5 = 53,
 SDLK_6 = 54,
 SDLK_7 = 55,
 SDLK_8 = 56,
 SDLK_9 = 57,
 SDLK_COLON = 58,
 SDLK_SEMICOLON = 59,
 SDLK_LESS = 60,
 SDLK_EQUALS = 61,
 SDLK_GREATER = 62,
 SDLK_QUESTION = 63,
 SDLK_AT = 64,



 SDLK_LEFTBRACKET = 91,
 SDLK_BACKSLASH = 92,
 SDLK_RIGHTBRACKET = 93,
 SDLK_CARET = 94,
 SDLK_UNDERSCORE = 95,
 SDLK_BACKQUOTE = 96,
 SDLK_a = 97,
 SDLK_b = 98,
 SDLK_c = 99,
 SDLK_d = 100,
 SDLK_e = 101,
 SDLK_f = 102,
 SDLK_g = 103,
 SDLK_h = 104,
 SDLK_i = 105,
 SDLK_j = 106,
 SDLK_k = 107,
 SDLK_l = 108,
 SDLK_m = 109,
 SDLK_n = 110,
 SDLK_o = 111,
 SDLK_p = 112,
 SDLK_q = 113,
 SDLK_r = 114,
 SDLK_s = 115,
 SDLK_t = 116,
 SDLK_u = 117,
 SDLK_v = 118,
 SDLK_w = 119,
 SDLK_x = 120,
 SDLK_y = 121,
 SDLK_z = 122,
 SDLK_DELETE = 127,





 SDLK_WORLD_0 = 160,
 SDLK_WORLD_1 = 161,
 SDLK_WORLD_2 = 162,
 SDLK_WORLD_3 = 163,
 SDLK_WORLD_4 = 164,
 SDLK_WORLD_5 = 165,
 SDLK_WORLD_6 = 166,
 SDLK_WORLD_7 = 167,
 SDLK_WORLD_8 = 168,
 SDLK_WORLD_9 = 169,
 SDLK_WORLD_10 = 170,
 SDLK_WORLD_11 = 171,
 SDLK_WORLD_12 = 172,
 SDLK_WORLD_13 = 173,
 SDLK_WORLD_14 = 174,
 SDLK_WORLD_15 = 175,
 SDLK_WORLD_16 = 176,
 SDLK_WORLD_17 = 177,
 SDLK_WORLD_18 = 178,
 SDLK_WORLD_19 = 179,
 SDLK_WORLD_20 = 180,
 SDLK_WORLD_21 = 181,
 SDLK_WORLD_22 = 182,
 SDLK_WORLD_23 = 183,
 SDLK_WORLD_24 = 184,
 SDLK_WORLD_25 = 185,
 SDLK_WORLD_26 = 186,
 SDLK_WORLD_27 = 187,
 SDLK_WORLD_28 = 188,
 SDLK_WORLD_29 = 189,
 SDLK_WORLD_30 = 190,
 SDLK_WORLD_31 = 191,
 SDLK_WORLD_32 = 192,
 SDLK_WORLD_33 = 193,
 SDLK_WORLD_34 = 194,
 SDLK_WORLD_35 = 195,
 SDLK_WORLD_36 = 196,
 SDLK_WORLD_37 = 197,
 SDLK_WORLD_38 = 198,
 SDLK_WORLD_39 = 199,
 SDLK_WORLD_40 = 200,
 SDLK_WORLD_41 = 201,
 SDLK_WORLD_42 = 202,
 SDLK_WORLD_43 = 203,
 SDLK_WORLD_44 = 204,
 SDLK_WORLD_45 = 205,
 SDLK_WORLD_46 = 206,
 SDLK_WORLD_47 = 207,
 SDLK_WORLD_48 = 208,
 SDLK_WORLD_49 = 209,
 SDLK_WORLD_50 = 210,
 SDLK_WORLD_51 = 211,
 SDLK_WORLD_52 = 212,
 SDLK_WORLD_53 = 213,
 SDLK_WORLD_54 = 214,
 SDLK_WORLD_55 = 215,
 SDLK_WORLD_56 = 216,
 SDLK_WORLD_57 = 217,
 SDLK_WORLD_58 = 218,
 SDLK_WORLD_59 = 219,
 SDLK_WORLD_60 = 220,
 SDLK_WORLD_61 = 221,
 SDLK_WORLD_62 = 222,
 SDLK_WORLD_63 = 223,
 SDLK_WORLD_64 = 224,
 SDLK_WORLD_65 = 225,
 SDLK_WORLD_66 = 226,
 SDLK_WORLD_67 = 227,
 SDLK_WORLD_68 = 228,
 SDLK_WORLD_69 = 229,
 SDLK_WORLD_70 = 230,
 SDLK_WORLD_71 = 231,
 SDLK_WORLD_72 = 232,
 SDLK_WORLD_73 = 233,
 SDLK_WORLD_74 = 234,
 SDLK_WORLD_75 = 235,
 SDLK_WORLD_76 = 236,
 SDLK_WORLD_77 = 237,
 SDLK_WORLD_78 = 238,
 SDLK_WORLD_79 = 239,
 SDLK_WORLD_80 = 240,
 SDLK_WORLD_81 = 241,
 SDLK_WORLD_82 = 242,
 SDLK_WORLD_83 = 243,
 SDLK_WORLD_84 = 244,
 SDLK_WORLD_85 = 245,
 SDLK_WORLD_86 = 246,
 SDLK_WORLD_87 = 247,
 SDLK_WORLD_88 = 248,
 SDLK_WORLD_89 = 249,
 SDLK_WORLD_90 = 250,
 SDLK_WORLD_91 = 251,
 SDLK_WORLD_92 = 252,
 SDLK_WORLD_93 = 253,
 SDLK_WORLD_94 = 254,
 SDLK_WORLD_95 = 255,




 SDLK_KP0 = 256,
 SDLK_KP1 = 257,
 SDLK_KP2 = 258,
 SDLK_KP3 = 259,
 SDLK_KP4 = 260,
 SDLK_KP5 = 261,
 SDLK_KP6 = 262,
 SDLK_KP7 = 263,
 SDLK_KP8 = 264,
 SDLK_KP9 = 265,
 SDLK_KP_PERIOD = 266,
 SDLK_KP_DIVIDE = 267,
 SDLK_KP_MULTIPLY = 268,
 SDLK_KP_MINUS = 269,
 SDLK_KP_PLUS = 270,
 SDLK_KP_ENTER = 271,
 SDLK_KP_EQUALS = 272,




 SDLK_UP = 273,
 SDLK_DOWN = 274,
 SDLK_RIGHT = 275,
 SDLK_LEFT = 276,
 SDLK_INSERT = 277,
 SDLK_HOME = 278,
 SDLK_END = 279,
 SDLK_PAGEUP = 280,
 SDLK_PAGEDOWN = 281,




 SDLK_F1 = 282,
 SDLK_F2 = 283,
 SDLK_F3 = 284,
 SDLK_F4 = 285,
 SDLK_F5 = 286,
 SDLK_F6 = 287,
 SDLK_F7 = 288,
 SDLK_F8 = 289,
 SDLK_F9 = 290,
 SDLK_F10 = 291,
 SDLK_F11 = 292,
 SDLK_F12 = 293,
 SDLK_F13 = 294,
 SDLK_F14 = 295,
 SDLK_F15 = 296,




 SDLK_NUMLOCK = 300,
 SDLK_CAPSLOCK = 301,
 SDLK_SCROLLOCK = 302,
 SDLK_RSHIFT = 303,
 SDLK_LSHIFT = 304,
 SDLK_RCTRL = 305,
 SDLK_LCTRL = 306,
 SDLK_RALT = 307,
 SDLK_LALT = 308,
 SDLK_RMETA = 309,
 SDLK_LMETA = 310,
 SDLK_LSUPER = 311,
 SDLK_RSUPER = 312,
 SDLK_MODE = 313,
 SDLK_COMPOSE = 314,




 SDLK_HELP = 315,
 SDLK_PRINT = 316,
 SDLK_SYSREQ = 317,
 SDLK_BREAK = 318,
 SDLK_MENU = 319,
 SDLK_POWER = 320,
 SDLK_EURO = 321,
 SDLK_UNDO = 322,




 SDLK_LAST
} SDLKey;


typedef enum {
 KMOD_NONE = 0x0000,
 KMOD_LSHIFT= 0x0001,
 KMOD_RSHIFT= 0x0002,
 KMOD_LCTRL = 0x0040,
 KMOD_RCTRL = 0x0080,
 KMOD_LALT = 0x0100,
 KMOD_RALT = 0x0200,
 KMOD_LMETA = 0x0400,
 KMOD_RMETA = 0x0800,
 KMOD_NUM = 0x1000,
 KMOD_CAPS = 0x2000,
 KMOD_MODE = 0x4000,
 KMOD_RESERVED = 0x8000
} SDLMod;
# 33 "/usr/local/include/SDL/SDL_keyboard.h" 2 3

# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 35 "/usr/local/include/SDL/SDL_keyboard.h" 2 3
# 59 "/usr/local/include/SDL/SDL_keyboard.h" 3
typedef struct SDL_keysym {
 Uint8 scancode;
 SDLKey sym;
 SDLMod mod;
 Uint16 unicode;
} SDL_keysym;
# 82 "/usr/local/include/SDL/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) int SDL_EnableUNICODE(int enable);
# 98 "/usr/local/include/SDL/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) int SDL_EnableKeyRepeat(int delay, int interval);
extern __attribute__ ((visibility("default"))) void SDL_GetKeyRepeat(int *delay, int *interval);
# 110 "/usr/local/include/SDL/SDL_keyboard.h" 3
extern __attribute__ ((visibility("default"))) Uint8 * SDL_GetKeyState(int *numkeys);




extern __attribute__ ((visibility("default"))) SDLMod SDL_GetModState(void);





extern __attribute__ ((visibility("default"))) void SDL_SetModState(SDLMod modstate);




extern __attribute__ ((visibility("default"))) char * SDL_GetKeyName(SDLKey key);






# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 134 "/usr/local/include/SDL/SDL_keyboard.h" 2 3
# 35 "/usr/local/include/SDL/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL/SDL_mouse.h" 1 3
# 32 "/usr/local/include/SDL/SDL_mouse.h" 3
# 1 "/usr/local/include/SDL/SDL_video.h" 1 3
# 34 "/usr/local/include/SDL/SDL_video.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 35 "/usr/local/include/SDL/SDL_video.h" 2 3
# 50 "/usr/local/include/SDL/SDL_video.h" 3
typedef struct SDL_Rect {
 Sint16 x, y;
 Uint16 w, h;
} SDL_Rect;

typedef struct SDL_Color {
 Uint8 r;
 Uint8 g;
 Uint8 b;
 Uint8 unused;
} SDL_Color;


typedef struct SDL_Palette {
 int ncolors;
 SDL_Color *colors;
} SDL_Palette;



typedef struct SDL_PixelFormat {
 SDL_Palette *palette;
 Uint8 BitsPerPixel;
 Uint8 BytesPerPixel;
 Uint8 Rloss;
 Uint8 Gloss;
 Uint8 Bloss;
 Uint8 Aloss;
 Uint8 Rshift;
 Uint8 Gshift;
 Uint8 Bshift;
 Uint8 Ashift;
 Uint32 Rmask;
 Uint32 Gmask;
 Uint32 Bmask;
 Uint32 Amask;


 Uint32 colorkey;

 Uint8 alpha;
} SDL_PixelFormat;




typedef struct SDL_Surface {
 Uint32 flags;
 SDL_PixelFormat *format;
 int w, h;
 Uint16 pitch;
 void *pixels;
 int offset;


 struct private_hwdata *hwdata;


 SDL_Rect clip_rect;
 Uint32 unused1;


 Uint32 locked;


 struct SDL_BlitMap *map;


 unsigned int format_version;


 int refcount;
} SDL_Surface;
# 166 "/usr/local/include/SDL/SDL_video.h" 3
typedef int (*SDL_blit)(struct SDL_Surface *src, SDL_Rect *srcrect,
   struct SDL_Surface *dst, SDL_Rect *dstrect);



typedef struct SDL_VideoInfo {
 Uint32 hw_available :1;
 Uint32 wm_available :1;
 Uint32 UnusedBits1 :6;
 Uint32 UnusedBits2 :1;
 Uint32 blit_hw :1;
 Uint32 blit_hw_CC :1;
 Uint32 blit_hw_A :1;
 Uint32 blit_sw :1;
 Uint32 blit_sw_CC :1;
 Uint32 blit_sw_A :1;
 Uint32 blit_fill :1;
 Uint32 UnusedBits3 :16;
 Uint32 video_mem;
 SDL_PixelFormat *vfmt;
 int current_w;
 int current_h;
} SDL_VideoInfo;
# 208 "/usr/local/include/SDL/SDL_video.h" 3
typedef struct SDL_Overlay {
 Uint32 format;
 int w, h;
 int planes;
 Uint16 *pitches;
 Uint8 **pixels;



 struct private_yuvhwfuncs *hwfuncs;
 struct private_yuvhwdata *hwdata;




 Uint32 hw_overlay :1;
 Uint32 UnusedBits :31;

} SDL_Overlay;



typedef enum {
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES,
    SDL_GL_ACCELERATED_VISUAL,
    SDL_GL_SWAP_CONTROL
} SDL_GLattr;
# 275 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_VideoInit(const char *driver_name, Uint32 flags);
extern __attribute__ ((visibility("default"))) void SDL_VideoQuit(void);







extern __attribute__ ((visibility("default"))) char * SDL_VideoDriverName(char *namebuf, int maxlen);







extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_GetVideoSurface(void);







extern __attribute__ ((visibility("default"))) const SDL_VideoInfo * SDL_GetVideoInfo(void);
# 313 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags);
# 324 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Rect ** SDL_ListModes(SDL_PixelFormat *format, Uint32 flags);
# 384 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_SetVideoMode
   (int width, int height, int bpp, Uint32 flags);
# 394 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_UpdateRects
  (SDL_Surface *screen, int numrects, SDL_Rect *rects);




extern __attribute__ ((visibility("default"))) void SDL_UpdateRect
  (SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h);
# 414 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_Flip(SDL_Surface *screen);
# 424 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetGamma(float red, float green, float blue);
# 438 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetGammaRamp(const Uint16 *red, const Uint16 *green, const Uint16 *blue);
# 449 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue);
# 466 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetColors(SDL_Surface *surface,
   SDL_Color *colors, int firstcolor, int ncolors);
# 485 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetPalette(SDL_Surface *surface, int flags,
       SDL_Color *colors, int firstcolor,
       int ncolors);




extern __attribute__ ((visibility("default"))) Uint32 SDL_MapRGB
(const SDL_PixelFormat * const format,
 const Uint8 r, const Uint8 g, const Uint8 b);




extern __attribute__ ((visibility("default"))) Uint32 SDL_MapRGBA
(const SDL_PixelFormat * const format,
 const Uint8 r, const Uint8 g, const Uint8 b, const Uint8 a);




extern __attribute__ ((visibility("default"))) void SDL_GetRGB(Uint32 pixel,
    const SDL_PixelFormat * const fmt,
    Uint8 *r, Uint8 *g, Uint8 *b);




extern __attribute__ ((visibility("default"))) void SDL_GetRGBA(Uint32 pixel,
    const SDL_PixelFormat * const fmt,
    Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
# 553 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurface
   (Uint32 flags, int width, int height, int depth,
   Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);

extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_CreateRGBSurfaceFrom(void *pixels,
   int width, int height, int depth, int pitch,
   Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
extern __attribute__ ((visibility("default"))) void SDL_FreeSurface(SDL_Surface *surface);
# 580 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_LockSurface(SDL_Surface *surface);
extern __attribute__ ((visibility("default"))) void SDL_UnlockSurface(SDL_Surface *surface);







extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_LoadBMP_RW(SDL_RWops *src, int freesrc);
# 599 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SaveBMP_RW
  (SDL_Surface *surface, SDL_RWops *dst, int freedst);
# 615 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetColorKey
   (SDL_Surface *surface, Uint32 flag, Uint32 key);
# 633 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);
# 647 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_bool SDL_SetClipRect(SDL_Surface *surface, const SDL_Rect *rect);






extern __attribute__ ((visibility("default"))) void SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect);
# 668 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_ConvertSurface
   (SDL_Surface *src, SDL_PixelFormat *fmt, Uint32 flags);
# 748 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_UpperBlit
   (SDL_Surface *src, SDL_Rect *srcrect,
    SDL_Surface *dst, SDL_Rect *dstrect);



extern __attribute__ ((visibility("default"))) int SDL_LowerBlit
   (SDL_Surface *src, SDL_Rect *srcrect,
    SDL_Surface *dst, SDL_Rect *dstrect);
# 767 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_FillRect
  (SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color);
# 781 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_DisplayFormat(SDL_Surface *surface);
# 795 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Surface * SDL_DisplayFormatAlpha(SDL_Surface *surface);
# 807 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_Overlay * SDL_CreateYUVOverlay(int width, int height,
    Uint32 format, SDL_Surface *display);


extern __attribute__ ((visibility("default"))) int SDL_LockYUVOverlay(SDL_Overlay *overlay);
extern __attribute__ ((visibility("default"))) void SDL_UnlockYUVOverlay(SDL_Overlay *overlay);







extern __attribute__ ((visibility("default"))) int SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect);


extern __attribute__ ((visibility("default"))) void SDL_FreeYUVOverlay(SDL_Overlay *overlay);
# 837 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GL_LoadLibrary(const char *path);




extern __attribute__ ((visibility("default"))) void * SDL_GL_GetProcAddress(const char* proc);




extern __attribute__ ((visibility("default"))) int SDL_GL_SetAttribute(SDL_GLattr attr, int value);
# 858 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_GL_GetAttribute(SDL_GLattr attr, int* value);




extern __attribute__ ((visibility("default"))) void SDL_GL_SwapBuffers(void);






extern __attribute__ ((visibility("default"))) void SDL_GL_UpdateRects(int numrects, SDL_Rect* rects);
extern __attribute__ ((visibility("default"))) void SDL_GL_Lock(void);
extern __attribute__ ((visibility("default"))) void SDL_GL_Unlock(void);
# 885 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) void SDL_WM_SetCaption(const char *title, const char *icon);



extern __attribute__ ((visibility("default"))) void SDL_WM_GetCaption(char **title, char **icon);







extern __attribute__ ((visibility("default"))) void SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask);






extern __attribute__ ((visibility("default"))) int SDL_WM_IconifyWindow(void);
# 921 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) int SDL_WM_ToggleFullScreen(SDL_Surface *surface);

typedef enum {
 SDL_GRAB_QUERY = -1,
 SDL_GRAB_OFF = 0,
 SDL_GRAB_ON = 1,
 SDL_GRAB_FULLSCREEN
} SDL_GrabMode;
# 937 "/usr/local/include/SDL/SDL_video.h" 3
extern __attribute__ ((visibility("default"))) SDL_GrabMode SDL_WM_GrabInput(SDL_GrabMode mode);




extern __attribute__ ((visibility("default"))) int SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect,
                                    SDL_Surface *dst, SDL_Rect *dstrect);





# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 950 "/usr/local/include/SDL/SDL_video.h" 2 3
# 33 "/usr/local/include/SDL/SDL_mouse.h" 2 3

# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 35 "/usr/local/include/SDL/SDL_mouse.h" 2 3





typedef struct WMcursor WMcursor;
typedef struct SDL_Cursor {
 SDL_Rect area;
 Sint16 hot_x, hot_y;
 Uint8 *data;
 Uint8 *mask;
 Uint8 *save[2];
 WMcursor *wm_cursor;
} SDL_Cursor;
# 57 "/usr/local/include/SDL/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) Uint8 SDL_GetMouseState(int *x, int *y);







extern __attribute__ ((visibility("default"))) Uint8 SDL_GetRelativeMouseState(int *x, int *y);




extern __attribute__ ((visibility("default"))) void SDL_WarpMouse(Uint16 x, Uint16 y);
# 85 "/usr/local/include/SDL/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_CreateCursor
  (Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);






extern __attribute__ ((visibility("default"))) void SDL_SetCursor(SDL_Cursor *cursor);




extern __attribute__ ((visibility("default"))) SDL_Cursor * SDL_GetCursor(void);




extern __attribute__ ((visibility("default"))) void SDL_FreeCursor(SDL_Cursor *cursor);
# 112 "/usr/local/include/SDL/SDL_mouse.h" 3
extern __attribute__ ((visibility("default"))) int SDL_ShowCursor(int toggle);
# 141 "/usr/local/include/SDL/SDL_mouse.h" 3
# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 142 "/usr/local/include/SDL/SDL_mouse.h" 2 3
# 36 "/usr/local/include/SDL/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL/SDL_joystick.h" 1 3
# 33 "/usr/local/include/SDL/SDL_joystick.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 34 "/usr/local/include/SDL/SDL_joystick.h" 2 3
# 46 "/usr/local/include/SDL/SDL_joystick.h" 3
struct _SDL_Joystick;
typedef struct _SDL_Joystick SDL_Joystick;





extern __attribute__ ((visibility("default"))) int SDL_NumJoysticks(void);







extern __attribute__ ((visibility("default"))) const char * SDL_JoystickName(int device_index);
# 73 "/usr/local/include/SDL/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) SDL_Joystick * SDL_JoystickOpen(int device_index);




extern __attribute__ ((visibility("default"))) int SDL_JoystickOpened(int device_index);




extern __attribute__ ((visibility("default"))) int SDL_JoystickIndex(SDL_Joystick *joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumAxes(SDL_Joystick *joystick);







extern __attribute__ ((visibility("default"))) int SDL_JoystickNumBalls(SDL_Joystick *joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumHats(SDL_Joystick *joystick);




extern __attribute__ ((visibility("default"))) int SDL_JoystickNumButtons(SDL_Joystick *joystick);







extern __attribute__ ((visibility("default"))) void SDL_JoystickUpdate(void);
# 125 "/usr/local/include/SDL/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) int SDL_JoystickEventState(int state);
# 134 "/usr/local/include/SDL/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
# 157 "/usr/local/include/SDL/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat);
# 166 "/usr/local/include/SDL/SDL_joystick.h" 3
extern __attribute__ ((visibility("default"))) int SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy);






extern __attribute__ ((visibility("default"))) Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button);




extern __attribute__ ((visibility("default"))) void SDL_JoystickClose(SDL_Joystick *joystick);






# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 186 "/usr/local/include/SDL/SDL_joystick.h" 2 3
# 37 "/usr/local/include/SDL/SDL_events.h" 2 3
# 1 "/usr/local/include/SDL/SDL_quit.h" 1 3
# 38 "/usr/local/include/SDL/SDL_events.h" 2 3

# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 40 "/usr/local/include/SDL/SDL_events.h" 2 3
# 52 "/usr/local/include/SDL/SDL_events.h" 3
typedef enum {
       SDL_NOEVENT = 0,
       SDL_ACTIVEEVENT,
       SDL_KEYDOWN,
       SDL_KEYUP,
       SDL_MOUSEMOTION,
       SDL_MOUSEBUTTONDOWN,
       SDL_MOUSEBUTTONUP,
       SDL_JOYAXISMOTION,
       SDL_JOYBALLMOTION,
       SDL_JOYHATMOTION,
       SDL_JOYBUTTONDOWN,
       SDL_JOYBUTTONUP,
       SDL_QUIT,
       SDL_SYSWMEVENT,
       SDL_EVENT_RESERVEDA,
       SDL_EVENT_RESERVEDB,
       SDL_VIDEORESIZE,
       SDL_VIDEOEXPOSE,
       SDL_EVENT_RESERVED2,
       SDL_EVENT_RESERVED3,
       SDL_EVENT_RESERVED4,
       SDL_EVENT_RESERVED5,
       SDL_EVENT_RESERVED6,
       SDL_EVENT_RESERVED7,

       SDL_USEREVENT = 24,



       SDL_NUMEVENTS = 32
} SDL_EventType;




typedef enum {
 SDL_ACTIVEEVENTMASK = (1<<(SDL_ACTIVEEVENT)),
 SDL_KEYDOWNMASK = (1<<(SDL_KEYDOWN)),
 SDL_KEYUPMASK = (1<<(SDL_KEYUP)),
 SDL_KEYEVENTMASK = (1<<(SDL_KEYDOWN))|
                           (1<<(SDL_KEYUP)),
 SDL_MOUSEMOTIONMASK = (1<<(SDL_MOUSEMOTION)),
 SDL_MOUSEBUTTONDOWNMASK = (1<<(SDL_MOUSEBUTTONDOWN)),
 SDL_MOUSEBUTTONUPMASK = (1<<(SDL_MOUSEBUTTONUP)),
 SDL_MOUSEEVENTMASK = (1<<(SDL_MOUSEMOTION))|
                           (1<<(SDL_MOUSEBUTTONDOWN))|
                           (1<<(SDL_MOUSEBUTTONUP)),
 SDL_JOYAXISMOTIONMASK = (1<<(SDL_JOYAXISMOTION)),
 SDL_JOYBALLMOTIONMASK = (1<<(SDL_JOYBALLMOTION)),
 SDL_JOYHATMOTIONMASK = (1<<(SDL_JOYHATMOTION)),
 SDL_JOYBUTTONDOWNMASK = (1<<(SDL_JOYBUTTONDOWN)),
 SDL_JOYBUTTONUPMASK = (1<<(SDL_JOYBUTTONUP)),
 SDL_JOYEVENTMASK = (1<<(SDL_JOYAXISMOTION))|
                           (1<<(SDL_JOYBALLMOTION))|
                           (1<<(SDL_JOYHATMOTION))|
                           (1<<(SDL_JOYBUTTONDOWN))|
                           (1<<(SDL_JOYBUTTONUP)),
 SDL_VIDEORESIZEMASK = (1<<(SDL_VIDEORESIZE)),
 SDL_VIDEOEXPOSEMASK = (1<<(SDL_VIDEOEXPOSE)),
 SDL_QUITMASK = (1<<(SDL_QUIT)),
 SDL_SYSWMEVENTMASK = (1<<(SDL_SYSWMEVENT))
} SDL_EventMask ;




typedef struct SDL_ActiveEvent {
 Uint8 type;
 Uint8 gain;
 Uint8 state;
} SDL_ActiveEvent;


typedef struct SDL_KeyboardEvent {
 Uint8 type;
 Uint8 which;
 Uint8 state;
 SDL_keysym keysym;
} SDL_KeyboardEvent;


typedef struct SDL_MouseMotionEvent {
 Uint8 type;
 Uint8 which;
 Uint8 state;
 Uint16 x, y;
 Sint16 xrel;
 Sint16 yrel;
} SDL_MouseMotionEvent;


typedef struct SDL_MouseButtonEvent {
 Uint8 type;
 Uint8 which;
 Uint8 button;
 Uint8 state;
 Uint16 x, y;
} SDL_MouseButtonEvent;


typedef struct SDL_JoyAxisEvent {
 Uint8 type;
 Uint8 which;
 Uint8 axis;
 Sint16 value;
} SDL_JoyAxisEvent;


typedef struct SDL_JoyBallEvent {
 Uint8 type;
 Uint8 which;
 Uint8 ball;
 Sint16 xrel;
 Sint16 yrel;
} SDL_JoyBallEvent;


typedef struct SDL_JoyHatEvent {
 Uint8 type;
 Uint8 which;
 Uint8 hat;
 Uint8 value;





} SDL_JoyHatEvent;


typedef struct SDL_JoyButtonEvent {
 Uint8 type;
 Uint8 which;
 Uint8 button;
 Uint8 state;
} SDL_JoyButtonEvent;





typedef struct SDL_ResizeEvent {
 Uint8 type;
 int w;
 int h;
} SDL_ResizeEvent;


typedef struct SDL_ExposeEvent {
 Uint8 type;
} SDL_ExposeEvent;


typedef struct SDL_QuitEvent {
 Uint8 type;
} SDL_QuitEvent;


typedef struct SDL_UserEvent {
 Uint8 type;
 int code;
 void *data1;
 void *data2;
} SDL_UserEvent;


struct SDL_SysWMmsg;
typedef struct SDL_SysWMmsg SDL_SysWMmsg;
typedef struct SDL_SysWMEvent {
 Uint8 type;
 SDL_SysWMmsg *msg;
} SDL_SysWMEvent;


typedef union SDL_Event {
 Uint8 type;
 SDL_ActiveEvent active;
 SDL_KeyboardEvent key;
 SDL_MouseMotionEvent motion;
 SDL_MouseButtonEvent button;
 SDL_JoyAxisEvent jaxis;
 SDL_JoyBallEvent jball;
 SDL_JoyHatEvent jhat;
 SDL_JoyButtonEvent jbutton;
 SDL_ResizeEvent resize;
 SDL_ExposeEvent expose;
 SDL_QuitEvent quit;
 SDL_UserEvent user;
 SDL_SysWMEvent syswm;
} SDL_Event;
# 251 "/usr/local/include/SDL/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) void SDL_PumpEvents(void);

typedef enum {
 SDL_ADDEVENT,
 SDL_PEEKEVENT,
 SDL_GETEVENT
} SDL_eventaction;
# 277 "/usr/local/include/SDL/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) int SDL_PeepEvents(SDL_Event *events, int numevents,
    SDL_eventaction action, Uint32 mask);





extern __attribute__ ((visibility("default"))) int SDL_PollEvent(SDL_Event *event);





extern __attribute__ ((visibility("default"))) int SDL_WaitEvent(SDL_Event *event);





extern __attribute__ ((visibility("default"))) int SDL_PushEvent(SDL_Event *event);



typedef int ( *SDL_EventFilter)(const SDL_Event *event);
# 323 "/usr/local/include/SDL/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) void SDL_SetEventFilter(SDL_EventFilter filter);





extern __attribute__ ((visibility("default"))) SDL_EventFilter SDL_GetEventFilter(void);
# 348 "/usr/local/include/SDL/SDL_events.h" 3
extern __attribute__ ((visibility("default"))) Uint8 SDL_EventState(Uint8 type, int state);





# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 355 "/usr/local/include/SDL/SDL_events.h" 2 3
# 38 "/usr/local/include/SDL/SDL.h" 2 3
# 1 "/usr/local/include/SDL/SDL_loadso.h" 1 3
# 49 "/usr/local/include/SDL/SDL_loadso.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 50 "/usr/local/include/SDL/SDL_loadso.h" 2 3
# 60 "/usr/local/include/SDL/SDL_loadso.h" 3
extern __attribute__ ((visibility("default"))) void * SDL_LoadObject(const char *sofile);






extern __attribute__ ((visibility("default"))) void * SDL_LoadFunction(void *handle, const char *name);


extern __attribute__ ((visibility("default"))) void SDL_UnloadObject(void *handle);





# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 77 "/usr/local/include/SDL/SDL_loadso.h" 2 3
# 39 "/usr/local/include/SDL/SDL.h" 2 3



# 1 "/usr/local/include/SDL/SDL_timer.h" 1 3
# 33 "/usr/local/include/SDL/SDL_timer.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 34 "/usr/local/include/SDL/SDL_timer.h" 2 3
# 49 "/usr/local/include/SDL/SDL_timer.h" 3
extern __attribute__ ((visibility("default"))) Uint32 SDL_GetTicks(void);


extern __attribute__ ((visibility("default"))) void SDL_Delay(Uint32 ms);


typedef Uint32 ( *SDL_TimerCallback)(Uint32 interval);
# 86 "/usr/local/include/SDL/SDL_timer.h" 3
extern __attribute__ ((visibility("default"))) int SDL_SetTimer(Uint32 interval, SDL_TimerCallback callback);
# 101 "/usr/local/include/SDL/SDL_timer.h" 3
typedef Uint32 ( *SDL_NewTimerCallback)(Uint32 interval, void *param);


typedef struct _SDL_TimerID *SDL_TimerID;




extern __attribute__ ((visibility("default"))) SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_NewTimerCallback callback, void *param);





extern __attribute__ ((visibility("default"))) SDL_bool SDL_RemoveTimer(SDL_TimerID t);







# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 124 "/usr/local/include/SDL/SDL_timer.h" 2 3
# 43 "/usr/local/include/SDL/SDL.h" 2 3

# 1 "/usr/local/include/SDL/SDL_version.h" 1 3
# 32 "/usr/local/include/SDL/SDL_version.h" 3
# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 33 "/usr/local/include/SDL/SDL_version.h" 2 3
# 47 "/usr/local/include/SDL/SDL_version.h" 3
typedef struct SDL_version {
 Uint8 major;
 Uint8 minor;
 Uint8 patch;
} SDL_version;
# 83 "/usr/local/include/SDL/SDL_version.h" 3
extern __attribute__ ((visibility("default"))) const SDL_version * SDL_Linked_Version(void);





# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 90 "/usr/local/include/SDL/SDL_version.h" 2 3
# 45 "/usr/local/include/SDL/SDL.h" 2 3

# 1 "/usr/local/include/SDL/begin_code.h" 1 3
# 47 "/usr/local/include/SDL/SDL.h" 2 3
# 76 "/usr/local/include/SDL/SDL.h" 3
extern __attribute__ ((visibility("default"))) int SDL_Init(Uint32 flags);


extern __attribute__ ((visibility("default"))) int SDL_InitSubSystem(Uint32 flags);


extern __attribute__ ((visibility("default"))) void SDL_QuitSubSystem(Uint32 flags);





extern __attribute__ ((visibility("default"))) Uint32 SDL_WasInit(Uint32 flags);




extern __attribute__ ((visibility("default"))) void SDL_Quit(void);





# 1 "/usr/local/include/SDL/close_code.h" 1 3
# 100 "/usr/local/include/SDL/SDL.h" 2 3
# 28 "sysc/sdldraw.h" 2

extern
void (*Draw_Pixel)(SDL_Surface *super,
                   Sint16 x, Sint16 y, Uint32 color);

extern
void (*Draw_Line)(SDL_Surface *super,
                  Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
                  Uint32 color);

extern
void (*Draw_Circle)(SDL_Surface *super,
                    Sint16 x0, Sint16 y0, Uint16 r,
                    Uint32 color);

extern
void (*Draw_FillCircle)(SDL_Surface *super,
                        Sint16 x0, Sint16 y0, Uint16 r,
                        Uint32 color);

extern
void (*Draw_HLine)(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 x1,
                      Uint32 color);

extern
void (*Draw_VLine)(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 y1,
                      Uint32 color);

extern
void (*Draw_Rect)(SDL_Surface *super,
                  Sint16 x,Sint16 y, Uint16 w,Uint16 h,
                  Uint32 color);

extern
void Draw_FillRect(SDL_Surface *super,
                   Sint16 x, Sint16 y, Sint16 w, Sint16 h, Uint32 color);


extern
void (*Draw_Ellipse)(SDL_Surface *super,
                        Sint16 x0, Sint16 y0,
                        Uint16 Xradius, Uint16 Yradius,
                        Uint32 color);

extern
void (*Draw_FillEllipse)(SDL_Surface *super,
                        Sint16 x0, Sint16 y0,
                        Uint16 Xradius, Uint16 Yradius,
                        Uint32 color);

extern
void (*Draw_Round)(SDL_Surface *super,
                   Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                   Uint16 corner, Uint32 color);

extern
void (*Draw_FillRound)(SDL_Surface *super,
                       Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                       Uint16 corner, Uint32 color);
# 33 "sysc/sdldrawlib.c" 2



# 1 "/usr/include/wchar.h" 1 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 1 3 4
# 353 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 129 "/usr/include/wchar.h" 3 4





struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) __attribute__ ((__nothrow__ , __leaf__));

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) __attribute__ ((__nothrow__ , __leaf__));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wcsdup (__const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));










extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 234 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));






extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 263 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 274 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) __attribute__ ((__nothrow__ , __leaf__));


extern size_t wcslen (__const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));

# 296 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));





extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));




# 317 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern int wmemcmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));






extern wint_t btowc (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int wctob (wint_t __c) __attribute__ ((__nothrow__ , __leaf__));



extern int mbsinit (__const mbstate_t *__ps) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) __attribute__ ((__nothrow__ , __leaf__));


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline wint_t
__attribute__ ((__nothrow__ , __leaf__)) btowc (int __c)
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) wctob (wint_t __wc)
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline size_t
__attribute__ ((__nothrow__ , __leaf__)) mbrlen (__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps)

{ return (__ps != ((void *)0)
   ? mbrtowc (((void *)0), __s, __n, __ps) : __mbrlen (__s, __n, ((void *)0))); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));






extern int wcwidth (wchar_t __c) __attribute__ ((__nothrow__ , __leaf__));



extern int wcswidth (__const wchar_t *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) __attribute__ ((__nothrow__ , __leaf__));






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) __attribute__ ((__nothrow__ , __leaf__));
# 527 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) __attribute__ ((__nothrow__ , __leaf__));



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__));






extern int fwide (__FILE *__fp, int __mode) __attribute__ ((__nothrow__ , __leaf__));






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;
# 677 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;
# 733 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 798 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 824 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 834 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 881 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/i386-linux-gnu/bits/wchar2.h" 1 3 4
# 25 "/usr/include/i386-linux-gnu/bits/wchar2.h" 3 4
extern wchar_t *__wmemcpy_chk (wchar_t *__restrict __s1,
          __const wchar_t *__restrict __s2, size_t __n,
          size_t __ns1) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wmemcpy_alias (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) __asm__ ("" "wmemcpy") __attribute__ ((__nothrow__ , __leaf__))


            ;
extern wchar_t *__wmemcpy_chk_warn (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n, size_t __ns1) __asm__ ("" "__wmemcpy_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wmemcpy called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wmemcpy (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n)

{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemcpy_chk (__s1, __s2, __n,
         __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmemcpy_chk_warn (__s1, __s2, __n,
       __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmemcpy_alias (__s1, __s2, __n);
}


extern wchar_t *__wmemmove_chk (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, size_t __ns1) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wmemmove_alias (wchar_t *__s1, __const wchar_t *__s2, size_t __n) __asm__ ("" "wmemmove") __attribute__ ((__nothrow__ , __leaf__))

                               ;
extern wchar_t *__wmemmove_chk_warn (wchar_t *__s1, __const wchar_t *__s2, size_t __n, size_t __ns1) __asm__ ("" "__wmemmove_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__((__warning__ ("wmemmove called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemmove_chk (__s1, __s2, __n,
          __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmemmove_chk_warn (__s1, __s2, __n,
        __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmemmove_alias (__s1, __s2, __n);
}



extern wchar_t *__wmempcpy_chk (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n,
    size_t __ns1) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wmempcpy_alias (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n) __asm__ ("" "wmempcpy") __attribute__ ((__nothrow__ , __leaf__))


                           ;
extern wchar_t *__wmempcpy_chk_warn (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n, size_t __ns1) __asm__ ("" "__wmempcpy_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wmempcpy called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wmempcpy (wchar_t *__restrict __s1, __const wchar_t *__restrict __s2, size_t __n)

{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmempcpy_chk (__s1, __s2, __n,
          __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmempcpy_chk_warn (__s1, __s2, __n,
        __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmempcpy_alias (__s1, __s2, __n);
}



extern wchar_t *__wmemset_chk (wchar_t *__s, wchar_t __c, size_t __n,
          size_t __ns) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wmemset_alias (wchar_t *__s, wchar_t __c, size_t __n) __asm__ ("" "wmemset") __attribute__ ((__nothrow__ , __leaf__))
                             ;
extern wchar_t *__wmemset_chk_warn (wchar_t *__s, wchar_t __c, size_t __n, size_t __ns) __asm__ ("" "__wmemset_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__((__warning__ ("wmemset called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wmemset (wchar_t *__s, wchar_t __c, size_t __n)
{
  if (__builtin_object_size (__s, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemset_chk (__s, __c, __n, __builtin_object_size (__s, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s, 0) / sizeof (wchar_t))
 return __wmemset_chk_warn (__s, __c, __n,
       __builtin_object_size (__s, 0) / sizeof (wchar_t));
    }
  return __wmemset_alias (__s, __c, __n);
}


extern wchar_t *__wcscpy_chk (wchar_t *__restrict __dest,
         __const wchar_t *__restrict __src,
         size_t __n) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wcscpy_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src) __asm__ ("" "wcscpy") __attribute__ ((__nothrow__ , __leaf__))

                                                ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wcscpy (wchar_t *__restrict __dest, __const wchar_t *__restrict __src)
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcscpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcscpy_alias (__dest, __src);
}


extern wchar_t *__wcpcpy_chk (wchar_t *__restrict __dest,
         __const wchar_t *__restrict __src,
         size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wcpcpy_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src) __asm__ ("" "wcpcpy") __attribute__ ((__nothrow__ , __leaf__))

                                                ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wcpcpy (wchar_t *__restrict __dest, __const wchar_t *__restrict __src)
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcpcpy_alias (__dest, __src);
}


extern wchar_t *__wcsncpy_chk (wchar_t *__restrict __dest,
          __const wchar_t *__restrict __src, size_t __n,
          size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wcsncpy_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n) __asm__ ("" "wcsncpy") __attribute__ ((__nothrow__ , __leaf__))


                          ;
extern wchar_t *__wcsncpy_chk_warn (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n, size_t __destlen) __asm__ ("" "__wcsncpy_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcsncpy called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wcsncpy (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n)

{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wcsncpy_chk (__dest, __src, __n,
         __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
      if (__n > __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t))
 return __wcsncpy_chk_warn (__dest, __src, __n,
       __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
    }
  return __wcsncpy_alias (__dest, __src, __n);
}


extern wchar_t *__wcpncpy_chk (wchar_t *__restrict __dest,
          __const wchar_t *__restrict __src, size_t __n,
          size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wcpncpy_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n) __asm__ ("" "wcpncpy") __attribute__ ((__nothrow__ , __leaf__))


                          ;
extern wchar_t *__wcpncpy_chk_warn (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n, size_t __destlen) __asm__ ("" "__wcpncpy_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcpncpy called with length bigger than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wcpncpy (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n)

{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wcpncpy_chk (__dest, __src, __n,
         __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
      if (__n > __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t))
 return __wcpncpy_chk_warn (__dest, __src, __n,
       __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
    }
  return __wcpncpy_alias (__dest, __src, __n);
}


extern wchar_t *__wcscat_chk (wchar_t *__restrict __dest,
         __const wchar_t *__restrict __src,
         size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wcscat_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src) __asm__ ("" "wcscat") __attribute__ ((__nothrow__ , __leaf__))

                                                ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wcscat (wchar_t *__restrict __dest, __const wchar_t *__restrict __src)
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcscat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcscat_alias (__dest, __src);
}


extern wchar_t *__wcsncat_chk (wchar_t *__restrict __dest,
          __const wchar_t *__restrict __src,
          size_t __n, size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern wchar_t *__wcsncat_alias (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n) __asm__ ("" "wcsncat") __attribute__ ((__nothrow__ , __leaf__))


                          ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) wchar_t *
__attribute__ ((__nothrow__ , __leaf__)) wcsncat (wchar_t *__restrict __dest, __const wchar_t *__restrict __src, size_t __n)

{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1)
    return __wcsncat_chk (__dest, __src, __n,
     __builtin_object_size (__dest, 2 > 1) / sizeof (wchar_t));
  return __wcsncat_alias (__dest, __src, __n);
}


extern int __swprintf_chk (wchar_t *__restrict __s, size_t __n,
      int __flag, size_t __s_len,
      __const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;

extern int __swprintf_alias (wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __fmt, ...) __asm__ ("" "swprintf") __attribute__ ((__nothrow__ , __leaf__))


             ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) swprintf (wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __fmt, ...)

{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 || 2 > 1)
    return __swprintf_chk (__s, __n, 2 - 1,
      __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
      __fmt, __builtin_va_arg_pack ());
  return __swprintf_alias (__s, __n, __fmt, __builtin_va_arg_pack ());
}
# 304 "/usr/include/i386-linux-gnu/bits/wchar2.h" 3 4
extern int __vswprintf_chk (wchar_t *__restrict __s, size_t __n,
       int __flag, size_t __s_len,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;

extern int __vswprintf_alias (wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __fmt, __gnuc_va_list __ap) __asm__ ("" "vswprintf") __attribute__ ((__nothrow__ , __leaf__))


                                     ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vswprintf (wchar_t *__restrict __s, size_t __n, __const wchar_t *__restrict __fmt, __gnuc_va_list __ap)

{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 || 2 > 1)
    return __vswprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t), __fmt, __ap);
  return __vswprintf_alias (__s, __n, __fmt, __ap);
}




extern int __fwprintf_chk (__FILE *__restrict __stream, int __flag,
      __const wchar_t *__restrict __format, ...);
extern int __wprintf_chk (int __flag, __const wchar_t *__restrict __format,
     ...);
extern int __vfwprintf_chk (__FILE *__restrict __stream, int __flag,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __ap);
extern int __vwprintf_chk (int __flag, __const wchar_t *__restrict __format,
      __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
wprintf (__const wchar_t *__restrict __fmt, ...)
{
  return __wprintf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
fwprintf (__FILE *__restrict __stream, __const wchar_t *__restrict __fmt, ...)
{
  return __fwprintf_chk (__stream, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
vwprintf (__const wchar_t *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vwprintf_chk (2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) int
vfwprintf (__FILE *__restrict __stream,
    __const wchar_t *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfwprintf_chk (__stream, 2 - 1, __fmt, __ap);
}



extern wchar_t *__fgetws_chk (wchar_t *__restrict __s, size_t __size, int __n,
         __FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_alias (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream) __asm__ ("" "fgetws")

                                              __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_chk_warn (wchar_t *__restrict __s, size_t __size, int __n, __FILE *__restrict __stream) __asm__ ("" "__fgetws_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgetws called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) wchar_t *
fgetws (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgetws_chk (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
        __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t))
 return __fgetws_chk_warn (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
      __n, __stream);
    }
  return __fgetws_alias (__s, __n, __stream);
}


extern wchar_t *__fgetws_unlocked_chk (wchar_t *__restrict __s, size_t __size,
           int __n, __FILE *__restrict __stream)
  __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_unlocked_alias (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream) __asm__ ("" "fgetws_unlocked")


  __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_unlocked_chk_warn (wchar_t *__restrict __s, size_t __size, int __n, __FILE *__restrict __stream) __asm__ ("" "__fgetws_unlocked_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgetws_unlocked called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) wchar_t *
fgetws_unlocked (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgetws_unlocked_chk (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
          __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t))
 return __fgetws_unlocked_chk_warn (__s, __builtin_object_size (__s, 2 > 1) / sizeof (wchar_t),
        __n, __stream);
    }
  return __fgetws_unlocked_alias (__s, __n, __stream);
}



extern size_t __wcrtomb_chk (char *__restrict __s, wchar_t __wchar,
        mbstate_t *__restrict __p,
        size_t __buflen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern size_t __wcrtomb_alias (char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps) __asm__ ("" "wcrtomb") __attribute__ ((__nothrow__ , __leaf__))

                                                __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcrtomb (char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps)

{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wcrtomb_chk (__s, __wchar, __ps, __builtin_object_size (__s, 2 > 1));
  return __wcrtomb_alias (__s, __wchar, __ps);
}


extern size_t __mbsrtowcs_chk (wchar_t *__restrict __dst,
          __const char **__restrict __src,
          size_t __len, mbstate_t *__restrict __ps,
          size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __mbsrtowcs_alias (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) __asm__ ("" "mbsrtowcs") __attribute__ ((__nothrow__ , __leaf__))



                   ;
extern size_t __mbsrtowcs_chk_warn (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) __asm__ ("" "__mbsrtowcs_chk") __attribute__ ((__nothrow__ , __leaf__))




     __attribute__((__warning__ ("mbsrtowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbsrtowcs (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbsrtowcs_chk (__dst, __src, __len, __ps,
    __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbsrtowcs_chk_warn (__dst, __src, __len, __ps,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbsrtowcs_alias (__dst, __src, __len, __ps);
}


extern size_t __wcsrtombs_chk (char *__restrict __dst,
          __const wchar_t **__restrict __src,
          size_t __len, mbstate_t *__restrict __ps,
          size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __wcsrtombs_alias (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) __asm__ ("" "wcsrtombs") __attribute__ ((__nothrow__ , __leaf__))



                   ;
extern size_t __wcsrtombs_chk_warn (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) __asm__ ("" "__wcsrtombs_chk") __attribute__ ((__nothrow__ , __leaf__))




    __attribute__((__warning__ ("wcsrtombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcsrtombs (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcsrtombs_chk (__dst, __src, __len, __ps, __builtin_object_size (__dst, 2 > 1));

      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcsrtombs_chk_warn (__dst, __src, __len, __ps, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcsrtombs_alias (__dst, __src, __len, __ps);
}



extern size_t __mbsnrtowcs_chk (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __nmc,
    size_t __len, mbstate_t *__restrict __ps,
    size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __mbsnrtowcs_alias (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) __asm__ ("" "mbsnrtowcs") __attribute__ ((__nothrow__ , __leaf__))



                    ;
extern size_t __mbsnrtowcs_chk_warn (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) __asm__ ("" "__mbsnrtowcs_chk") __attribute__ ((__nothrow__ , __leaf__))




     __attribute__((__warning__ ("mbsnrtowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbsnrtowcs (wchar_t *__restrict __dst, __const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbsnrtowcs_chk (__dst, __src, __nmc, __len, __ps,
     __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbsnrtowcs_chk_warn (__dst, __src, __nmc, __len, __ps,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbsnrtowcs_alias (__dst, __src, __nmc, __len, __ps);
}


extern size_t __wcsnrtombs_chk (char *__restrict __dst,
    __const wchar_t **__restrict __src,
    size_t __nwc, size_t __len,
    mbstate_t *__restrict __ps, size_t __dstlen)
     __attribute__ ((__nothrow__ , __leaf__));
extern size_t __wcsnrtombs_alias (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) __asm__ ("" "wcsnrtombs") __attribute__ ((__nothrow__ , __leaf__))



                                                  ;
extern size_t __wcsnrtombs_chk_warn (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) __asm__ ("" "__wcsnrtombs_chk") __attribute__ ((__nothrow__ , __leaf__))





     __attribute__((__warning__ ("wcsnrtombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcsnrtombs (char *__restrict __dst, __const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcsnrtombs_chk (__dst, __src, __nwc, __len, __ps,
     __builtin_object_size (__dst, 2 > 1));

      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcsnrtombs_chk_warn (__dst, __src, __nwc, __len, __ps,
          __builtin_object_size (__dst, 2 > 1));
    }
  return __wcsnrtombs_alias (__dst, __src, __nwc, __len, __ps);
}
# 882 "/usr/include/wchar.h" 2 3 4







# 37 "sysc/sdldrawlib.c" 2



static void Draw_Init(void);





# 1 "sysc/draw/Draw_Pixel.c" 1
# 48 "sysc/draw/Draw_Pixel.c"
void Draw_Pixel_1(SDL_Surface *super,
                      Sint16 x, Sint16 y, Uint32 color)
{







  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  *(0+(0+(Uint8*)super->pixels + y*super->pitch + x*1))=(Uint8)color;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 47 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Pixel.c" 1
# 48 "sysc/draw/Draw_Pixel.c"
void Draw_Pixel_2(SDL_Surface *super,
                      Sint16 x, Sint16 y, Uint32 color)
{







  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  *((Uint16*)(0+(Uint8*)super->pixels + y*super->pitch + x*2))=(Uint16)color;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 53 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Pixel.c" 1
# 48 "sysc/draw/Draw_Pixel.c"
void Draw_Pixel_3(SDL_Surface *super,
                      Sint16 x, Sint16 y, Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);



  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  *(0+(1+(Uint8*)super->pixels + y*super->pitch + x*3))=colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)super->pixels + y*super->pitch + x*3))=colorbyte2; *(0+(2+(Uint8*)super->pixels + y*super->pitch + x*3))=colorbyte0; }else{ *(0+(0+(Uint8*)super->pixels + y*super->pitch + x*3))=colorbyte0; *(0+(2+(Uint8*)super->pixels + y*super->pitch + x*3))=colorbyte2; }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 59 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Pixel.c" 1
# 48 "sysc/draw/Draw_Pixel.c"
void Draw_Pixel_4(SDL_Surface *super,
                      Sint16 x, Sint16 y, Uint32 color)
{







  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  *((Uint32*)(0+(Uint8*)super->pixels + y*super->pitch + x*4))=color;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 65 "sysc/sdldrawlib.c" 2



static
void Draw_Pixel_Init(SDL_Surface *super,
                     Sint16 x, Sint16 y, Uint32 color)
{
  Draw_Init();
  Draw_Pixel(super, x, y, color);
}

void (*Draw_Pixel)(SDL_Surface *super,
                   Sint16 x, Sint16 y, Uint32 color) = Draw_Pixel_Init;







# 1 "sysc/draw/Draw_Line.c" 1
# 51 "sysc/draw/Draw_Line.c"
void Draw_Line_1(SDL_Surface *super,
                      Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
                      Uint32 color)
{
# 64 "sysc/draw/Draw_Line.c"
  register Sint16 dx;
  register Sint16 dy;

  Sint16 fbXincr, fbYincr, fbXYincr;
  Sint16 dPr, dPru, P;

  Sint16 pixx = super->format->BytesPerPixel;
  Sint16 pixy = super->pitch;

  Uint8 *AfbAddr, *BfbAddr;
# 82 "sysc/draw/Draw_Line.c"
  AfbAddr = ((Uint8*)super->pixels) + pixx * (int)x1 + pixy * (int)y1;
  BfbAddr = ((Uint8*)super->pixels) + pixx * (int)x2 + pixy * (int)y2;




  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  fbXincr=pixx;
  if ( (dx=x2-x1) >= 0 ) goto AFTERNEGX;
    dx = -dx;
    fbXincr = -pixx;
  AFTERNEGX:

  fbYincr=pixy;
  if ( (dy=y2-y1) >= 0) goto AFTERNEGY;
    fbYincr = -pixy;
    dy = -dy;
  AFTERNEGY:

  fbXYincr = fbXincr+fbYincr;

  if (dy > dx) goto YisIndependent;


    dPr = dy+dy;
    P = -dx;
    dPru = P+P;
    dy = dx>>1;
    XLOOP:
      *(0+(0+(Uint8*)AfbAddr))=color;;
      *(0+(0+(Uint8*)BfbAddr))=color;;
      if ((P+=dPr) > 0) goto RightAndUp;

        AfbAddr+=fbXincr;
 BfbAddr-=fbXincr;
        if ((dy=dy-1) > 0) goto XLOOP;
        *(0+(0+(Uint8*)AfbAddr))=color;
        if (( dx & 1) == 0) goto END_P;
        *(0+(0+(Uint8*)BfbAddr))=color;;
        goto END_P;
      RightAndUp:
 AfbAddr+=fbXYincr;
 BfbAddr-=fbXYincr;
 P+=dPru;
 if ((dy=dy-1) > 0) goto XLOOP;
 *(0+(0+(Uint8*)AfbAddr))=color;;
 if ((dx & 1) == 0) goto END_P;
 *(0+(0+(Uint8*)BfbAddr))=color;;
 goto END_P;

    YisIndependent:
 dPr = dx+dx;
 P = -dy;
 dPru = P+P;
 dx = dy >>1;
     YLOOP:
        *(0+(0+(Uint8*)AfbAddr))=color;;
        *(0+(0+(Uint8*)BfbAddr))=color;;
        if ((P+=dPr) > 0) goto RightAndUp2;

            AfbAddr+=fbYincr;
            BfbAddr-=fbYincr;
            if ((dx=dx-1) > 0) goto YLOOP;
            *(0+(0+(Uint8*)AfbAddr))=color;;
            if ((dy & 1) == 0) goto END_P;
            *(0+(0+(Uint8*)BfbAddr))=color;;
            goto END_P;
        RightAndUp2:
             AfbAddr+=fbXYincr;
             BfbAddr-=fbXYincr;
            P+=dPru;
            if ((dx=dx-1) > 0) goto YLOOP;
            *(0+(0+(Uint8*)AfbAddr))=color;;
            if ((dy & 1) == 0) goto END_P;
            *(0+(0+(Uint8*)BfbAddr))=color;;

END_P:

  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 86 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Line.c" 1
# 51 "sysc/draw/Draw_Line.c"
void Draw_Line_2(SDL_Surface *super,
                      Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
                      Uint32 color)
{
# 64 "sysc/draw/Draw_Line.c"
  register Sint16 dx;
  register Sint16 dy;

  Sint16 fbXincr, fbYincr, fbXYincr;
  Sint16 dPr, dPru, P;

  Sint16 pixx = super->format->BytesPerPixel;
  Sint16 pixy = super->pitch;

  Uint8 *AfbAddr, *BfbAddr;
# 82 "sysc/draw/Draw_Line.c"
  AfbAddr = ((Uint8*)super->pixels) + pixx * (int)x1 + pixy * (int)y1;
  BfbAddr = ((Uint8*)super->pixels) + pixx * (int)x2 + pixy * (int)y2;




  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  fbXincr=pixx;
  if ( (dx=x2-x1) >= 0 ) goto AFTERNEGX;
    dx = -dx;
    fbXincr = -pixx;
  AFTERNEGX:

  fbYincr=pixy;
  if ( (dy=y2-y1) >= 0) goto AFTERNEGY;
    fbYincr = -pixy;
    dy = -dy;
  AFTERNEGY:

  fbXYincr = fbXincr+fbYincr;

  if (dy > dx) goto YisIndependent;


    dPr = dy+dy;
    P = -dx;
    dPru = P+P;
    dy = dx>>1;
    XLOOP:
      *((Uint16*)(0+(Uint8*)AfbAddr))=color;;
      *((Uint16*)(0+(Uint8*)BfbAddr))=color;;
      if ((P+=dPr) > 0) goto RightAndUp;

        AfbAddr+=fbXincr;
 BfbAddr-=fbXincr;
        if ((dy=dy-1) > 0) goto XLOOP;
        *((Uint16*)(0+(Uint8*)AfbAddr))=color;
        if (( dx & 1) == 0) goto END_P;
        *((Uint16*)(0+(Uint8*)BfbAddr))=color;;
        goto END_P;
      RightAndUp:
 AfbAddr+=fbXYincr;
 BfbAddr-=fbXYincr;
 P+=dPru;
 if ((dy=dy-1) > 0) goto XLOOP;
 *((Uint16*)(0+(Uint8*)AfbAddr))=color;;
 if ((dx & 1) == 0) goto END_P;
 *((Uint16*)(0+(Uint8*)BfbAddr))=color;;
 goto END_P;

    YisIndependent:
 dPr = dx+dx;
 P = -dy;
 dPru = P+P;
 dx = dy >>1;
     YLOOP:
        *((Uint16*)(0+(Uint8*)AfbAddr))=color;;
        *((Uint16*)(0+(Uint8*)BfbAddr))=color;;
        if ((P+=dPr) > 0) goto RightAndUp2;

            AfbAddr+=fbYincr;
            BfbAddr-=fbYincr;
            if ((dx=dx-1) > 0) goto YLOOP;
            *((Uint16*)(0+(Uint8*)AfbAddr))=color;;
            if ((dy & 1) == 0) goto END_P;
            *((Uint16*)(0+(Uint8*)BfbAddr))=color;;
            goto END_P;
        RightAndUp2:
             AfbAddr+=fbXYincr;
             BfbAddr-=fbXYincr;
            P+=dPru;
            if ((dx=dx-1) > 0) goto YLOOP;
            *((Uint16*)(0+(Uint8*)AfbAddr))=color;;
            if ((dy & 1) == 0) goto END_P;
            *((Uint16*)(0+(Uint8*)BfbAddr))=color;;

END_P:

  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 92 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Line.c" 1
# 51 "sysc/draw/Draw_Line.c"
void Draw_Line_3(SDL_Surface *super,
                      Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
                      Uint32 color)
{




  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  register Sint16 dx;
  register Sint16 dy;

  Sint16 fbXincr, fbYincr, fbXYincr;
  Sint16 dPr, dPru, P;

  Sint16 pixx = super->format->BytesPerPixel;
  Sint16 pixy = super->pitch;

  Uint8 *AfbAddr, *BfbAddr;
# 82 "sysc/draw/Draw_Line.c"
  AfbAddr = ((Uint8*)super->pixels) + pixx * (int)x1 + pixy * (int)y1;
  BfbAddr = ((Uint8*)super->pixels) + pixx * (int)x2 + pixy * (int)y2;




  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  fbXincr=pixx;
  if ( (dx=x2-x1) >= 0 ) goto AFTERNEGX;
    dx = -dx;
    fbXincr = -pixx;
  AFTERNEGX:

  fbYincr=pixy;
  if ( (dy=y2-y1) >= 0) goto AFTERNEGY;
    fbYincr = -pixy;
    dy = -dy;
  AFTERNEGY:

  fbXYincr = fbXincr+fbYincr;

  if (dy > dx) goto YisIndependent;


    dPr = dy+dy;
    P = -dx;
    dPru = P+P;
    dy = dx>>1;
    XLOOP:
      *(0+(1+(Uint8*)AfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte2; };
      *(0+(1+(Uint8*)BfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte2; };
      if ((P+=dPr) > 0) goto RightAndUp;

        AfbAddr+=fbXincr;
 BfbAddr-=fbXincr;
        if ((dy=dy-1) > 0) goto XLOOP;
        *(0+(1+(Uint8*)AfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte2; }
        if (( dx & 1) == 0) goto END_P;
        *(0+(1+(Uint8*)BfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte2; };
        goto END_P;
      RightAndUp:
 AfbAddr+=fbXYincr;
 BfbAddr-=fbXYincr;
 P+=dPru;
 if ((dy=dy-1) > 0) goto XLOOP;
 *(0+(1+(Uint8*)AfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte2; };
 if ((dx & 1) == 0) goto END_P;
 *(0+(1+(Uint8*)BfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte2; };
 goto END_P;

    YisIndependent:
 dPr = dx+dx;
 P = -dy;
 dPru = P+P;
 dx = dy >>1;
     YLOOP:
        *(0+(1+(Uint8*)AfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte2; };
        *(0+(1+(Uint8*)BfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte2; };
        if ((P+=dPr) > 0) goto RightAndUp2;

            AfbAddr+=fbYincr;
            BfbAddr-=fbYincr;
            if ((dx=dx-1) > 0) goto YLOOP;
            *(0+(1+(Uint8*)AfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte2; };
            if ((dy & 1) == 0) goto END_P;
            *(0+(1+(Uint8*)BfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte2; };
            goto END_P;
        RightAndUp2:
             AfbAddr+=fbXYincr;
             BfbAddr-=fbXYincr;
            P+=dPru;
            if ((dx=dx-1) > 0) goto YLOOP;
            *(0+(1+(Uint8*)AfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)AfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)AfbAddr))=(Uint8)colorbyte2; };
            if ((dy & 1) == 0) goto END_P;
            *(0+(1+(Uint8*)BfbAddr))=(Uint8)colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte2; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte0; }else{ *(0+(0+(Uint8*)BfbAddr))=(Uint8)colorbyte0; *(0+(2+(Uint8*)BfbAddr))=(Uint8)colorbyte2; };

END_P:

  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 98 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Line.c" 1
# 51 "sysc/draw/Draw_Line.c"
void Draw_Line_4(SDL_Surface *super,
                      Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
                      Uint32 color)
{
# 64 "sysc/draw/Draw_Line.c"
  register Sint16 dx;
  register Sint16 dy;

  Sint16 fbXincr, fbYincr, fbXYincr;
  Sint16 dPr, dPru, P;

  Sint16 pixx = super->format->BytesPerPixel;
  Sint16 pixy = super->pitch;

  Uint8 *AfbAddr, *BfbAddr;
# 82 "sysc/draw/Draw_Line.c"
  AfbAddr = ((Uint8*)super->pixels) + pixx * (int)x1 + pixy * (int)y1;
  BfbAddr = ((Uint8*)super->pixels) + pixx * (int)x2 + pixy * (int)y2;




  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  fbXincr=pixx;
  if ( (dx=x2-x1) >= 0 ) goto AFTERNEGX;
    dx = -dx;
    fbXincr = -pixx;
  AFTERNEGX:

  fbYincr=pixy;
  if ( (dy=y2-y1) >= 0) goto AFTERNEGY;
    fbYincr = -pixy;
    dy = -dy;
  AFTERNEGY:

  fbXYincr = fbXincr+fbYincr;

  if (dy > dx) goto YisIndependent;


    dPr = dy+dy;
    P = -dx;
    dPru = P+P;
    dy = dx>>1;
    XLOOP:
      *((Uint32*)(0+(Uint8*)AfbAddr))=color;;
      *((Uint32*)(0+(Uint8*)BfbAddr))=color;;
      if ((P+=dPr) > 0) goto RightAndUp;

        AfbAddr+=fbXincr;
 BfbAddr-=fbXincr;
        if ((dy=dy-1) > 0) goto XLOOP;
        *((Uint32*)(0+(Uint8*)AfbAddr))=color;
        if (( dx & 1) == 0) goto END_P;
        *((Uint32*)(0+(Uint8*)BfbAddr))=color;;
        goto END_P;
      RightAndUp:
 AfbAddr+=fbXYincr;
 BfbAddr-=fbXYincr;
 P+=dPru;
 if ((dy=dy-1) > 0) goto XLOOP;
 *((Uint32*)(0+(Uint8*)AfbAddr))=color;;
 if ((dx & 1) == 0) goto END_P;
 *((Uint32*)(0+(Uint8*)BfbAddr))=color;;
 goto END_P;

    YisIndependent:
 dPr = dx+dx;
 P = -dy;
 dPru = P+P;
 dx = dy >>1;
     YLOOP:
        *((Uint32*)(0+(Uint8*)AfbAddr))=color;;
        *((Uint32*)(0+(Uint8*)BfbAddr))=color;;
        if ((P+=dPr) > 0) goto RightAndUp2;

            AfbAddr+=fbYincr;
            BfbAddr-=fbYincr;
            if ((dx=dx-1) > 0) goto YLOOP;
            *((Uint32*)(0+(Uint8*)AfbAddr))=color;;
            if ((dy & 1) == 0) goto END_P;
            *((Uint32*)(0+(Uint8*)BfbAddr))=color;;
            goto END_P;
        RightAndUp2:
             AfbAddr+=fbXYincr;
             BfbAddr-=fbXYincr;
            P+=dPru;
            if ((dx=dx-1) > 0) goto YLOOP;
            *((Uint32*)(0+(Uint8*)AfbAddr))=color;;
            if ((dy & 1) == 0) goto END_P;
            *((Uint32*)(0+(Uint8*)BfbAddr))=color;;

END_P:

  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 104 "sysc/sdldrawlib.c" 2



static
void Draw_Line_Init(SDL_Surface *super,
                    Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
                    Uint32 color)
{
  Draw_Init();
  Draw_Line(super, x1, y1, x2, y2, color);
}

void (*Draw_Line)(SDL_Surface *super,
                  Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2,
                  Uint32 color) = Draw_Line_Init;







# 1 "sysc/draw/Draw_Circle.c" 1
# 64 "sysc/draw/Draw_Circle.c"
void Draw_Circle_1(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{






  Sint16 x = 0;
  Sint16 y = r-1;
  Sint16 d = 3 - 2*r;
  Sint16 diagonalInc = 10 - 4*r;
  Sint16 rightInc = 6;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
    if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x <= y) {

    *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0+y)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0+y)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0-y)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0-y)*1)) = color;

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      y -= 1;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    x += 1;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 127 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Circle.c" 1
# 64 "sysc/draw/Draw_Circle.c"
void Draw_Circle_2(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{






  Sint16 x = 0;
  Sint16 y = r-1;
  Sint16 d = 3 - 2*r;
  Sint16 diagonalInc = 10 - 4*r;
  Sint16 rightInc = 6;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
    if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x <= y) {

    *((Uint16*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0+y)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0+y)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0-y)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0-y)*2)) = color;

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      y -= 1;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    x += 1;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 133 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Circle.c" 1
# 64 "sysc/draw/Draw_Circle.c"
void Draw_Circle_3(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  Sint16 x = 0;
  Sint16 y = r-1;
  Sint16 d = 3 - 2*r;
  Sint16 diagonalInc = 10 - 4*r;
  Sint16 rightInc = 6;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
    if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x <= y) {

    *(0+(1+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0+y)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0+y)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0-y)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0-y)*3)) = colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0+y)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0+y)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0-y)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0-y)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0+y)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0+y)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0-y)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0-y)*3)) = colorbyte0; }else{ *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0+y)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0+y)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0-y)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0-y)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0+y)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0+y)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0-y)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0-y)*3)) = colorbyte2; }

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      y -= 1;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    x += 1;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 139 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Circle.c" 1
# 64 "sysc/draw/Draw_Circle.c"
void Draw_Circle_4(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{






  Sint16 x = 0;
  Sint16 y = r-1;
  Sint16 d = 3 - 2*r;
  Sint16 diagonalInc = 10 - 4*r;
  Sint16 rightInc = 6;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
    if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x <= y) {

    *((Uint32*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0+y)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0+y)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0+x)*super->pitch + (x0-y)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0-x)*super->pitch + (x0-y)*4)) = color;

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      y -= 1;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    x += 1;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 145 "sysc/sdldrawlib.c" 2



static
void Draw_Circle_Init(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{
  Draw_Init();
  Draw_Circle(super, x0, y0, r, color);
}


void (*Draw_Circle)(SDL_Surface *super,
                    Sint16 x0, Sint16 y0, Uint16 r,
                    Uint32 color) = Draw_Circle_Init;







# 1 "sysc/draw/Draw_FillCircle.c" 1
# 167 "sysc/draw/Draw_FillCircle.c"
void Draw_FillCircle_1(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;




  Sint16 x = 0;
  Sint16 y = r-1;
  Sint16 d = 3 - 2*r;
  Sint16 diagonalInc = 10 - 4*r;
  Sint16 rightInc = 6;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x <= y) {

    p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*1);
    p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*1);

    memset(p0, color, 2*x+1); memset(p1, color, 2*x+1); p0 = ((Uint8*)super->pixels+ (y0+x)*super->pitch+ (x0-y)); p1 = ((Uint8*)super->pixels+ (y0-x)*super->pitch+ (x0-y)); memset(p0, color, 2*y+1); memset(p1, color, 2*y+1);

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      y -= 1;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    x += 1;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 169 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillCircle.c" 1
# 167 "sysc/draw/Draw_FillCircle.c"
void Draw_FillCircle_2(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;

  register Sint16 i;


  Sint16 x = 0;
  Sint16 y = r-1;
  Sint16 d = 3 - 2*r;
  Sint16 diagonalInc = 10 - 4*r;
  Sint16 rightInc = 6;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x <= y) {

    p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*2);
    p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*2);

    i = 2*x+1; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 3: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 2: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 1: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; }while( (i-=4) > 0 ); } p0 = ((Uint8*)super->pixels+ (y0+x)*super->pitch+ (x0-y)*2); p1 = ((Uint8*)super->pixels+ (y0-x)*super->pitch+ (x0-y)*2); i = 2*y+1; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 3: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 2: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 1: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; }while( (i-=4) > 0 ); }

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      y -= 1;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    x += 1;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 175 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillCircle.c" 1
# 167 "sysc/draw/Draw_FillCircle.c"
void Draw_FillCircle_3(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  register Uint8 *p0;
  register Uint8 *p1;

  register Sint16 i;


  Sint16 x = 0;
  Sint16 y = r-1;
  Sint16 d = 3 - 2*r;
  Sint16 diagonalInc = 10 - 4*r;
  Sint16 rightInc = 6;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x <= y) {

    p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*3);
    p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*3);

    i = 2*x+1; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; }while( (i-=4) > 0 ); } p0 = ((Uint8*)super->pixels+ (y0+x)*super->pitch+ (x0-y)*3); p1 = ((Uint8*)super->pixels+ (y0-x)*super->pitch+ (x0-y)*3); i = 2*y+1; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; }while( (i-=4) > 0 ); }

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      y -= 1;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    x += 1;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 181 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillCircle.c" 1
# 167 "sysc/draw/Draw_FillCircle.c"
void Draw_FillCircle_4(SDL_Surface *super,
                      Sint16 x0, Sint16 y0, Uint16 r,
                      Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;

  register Sint16 i;


  Sint16 x = 0;
  Sint16 y = r-1;
  Sint16 d = 3 - 2*r;
  Sint16 diagonalInc = 10 - 4*r;
  Sint16 rightInc = 6;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x <= y) {

    p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*4);
    p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*4);

    if (sizeof(wchar_t) == sizeof(Uint32)) { wmemset((wchar_t*)p0, color, 2*x+1); wmemset((wchar_t*)p1, color, 2*x+1); p0 = ((Uint8*)super->pixels+ (y0+x)*super->pitch+ (x0-y)*4); p1 = ((Uint8*)super->pixels+ (y0-x)*super->pitch+ (x0-y)*4); wmemset((wchar_t*)p0, color, 2*y+1); wmemset((wchar_t*)p1, color, 2*y+1); } else { i = 2*x+1; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 3: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 2: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 1: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; }while( (i-=4) > 0 ); } p0 = ((Uint8*)super->pixels+ (y0+x)*super->pitch+ (x0-y)*4); p1 = ((Uint8*)super->pixels+ (y0-x)*super->pitch+ (x0-y)*4); i = 2*y+1; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 3: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 2: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 1: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; }while( (i-=4) > 0 ); } }

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      y -= 1;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    x += 1;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 187 "sysc/sdldrawlib.c" 2



static
void Draw_FillCircle_Init(SDL_Surface *super,
                          Sint16 x0, Sint16 y0, Uint16 r,
                          Uint32 color)
{
  Draw_Init();
  Draw_FillCircle(super, x0, y0, r, color);
}


void (*Draw_FillCircle)(SDL_Surface *super,
                        Sint16 x0, Sint16 y0, Uint16 r,
                        Uint32 color) = Draw_FillCircle_Init;







# 1 "sysc/draw/Draw_HLine.c" 1
# 91 "sysc/draw/Draw_HLine.c"
void Draw_HLine_1(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 x1,
                      Uint32 color)
{






  register Uint8 *p;
  register Sint16 i;

  if (x0 > x1) { i=x1; x1=x0; x0=i; }
  p = (Uint8*)super->pixels + y0 * super->pitch + x0 * 1;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  memset(p, color, x1-x0+1);


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 211 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_HLine.c" 1
# 91 "sysc/draw/Draw_HLine.c"
void Draw_HLine_2(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 x1,
                      Uint32 color)
{






  register Uint8 *p;
  register Sint16 i;

  if (x0 > x1) { i=x1; x1=x0; x0=i; }
  p = (Uint8*)super->pixels + y0 * super->pitch + x0 * 2;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i = x1-x0+1; switch( i % 4 ) { do{ case 0: *(Uint16*)p = color; p+=2; case 3: *(Uint16*)p = color; p+=2; case 2: *(Uint16*)p = color; p+=2; case 1: *(Uint16*)p = color; p+=2; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 217 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_HLine.c" 1
# 91 "sysc/draw/Draw_HLine.c"
void Draw_HLine_3(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 x1,
                      Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  register Uint8 *p;
  register Sint16 i;

  if (x0 > x1) { i=x1; x1=x0; x0=i; }
  p = (Uint8*)super->pixels + y0 * super->pitch + x0 * 3;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i = x1-x0+1; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p[0] = colorbyte2; p[1] = colorbyte1; p[2] = colorbyte0; } else { p[0] = colorbyte0; p[1] = colorbyte1; p[2] = colorbyte2; } p+=3; case 3: if (1234 == 4321) { p[0] = colorbyte2; p[1] = colorbyte1; p[2] = colorbyte0; } else { p[0] = colorbyte0; p[1] = colorbyte1; p[2] = colorbyte2; } p+=3; case 2: if (1234 == 4321) { p[0] = colorbyte2; p[1] = colorbyte1; p[2] = colorbyte0; } else { p[0] = colorbyte0; p[1] = colorbyte1; p[2] = colorbyte2; } p+=3; case 1: if (1234 == 4321) { p[0] = colorbyte2; p[1] = colorbyte1; p[2] = colorbyte0; } else { p[0] = colorbyte0; p[1] = colorbyte1; p[2] = colorbyte2; } p+=3; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 223 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_HLine.c" 1
# 91 "sysc/draw/Draw_HLine.c"
void Draw_HLine_4(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 x1,
                      Uint32 color)
{






  register Uint8 *p;
  register Sint16 i;

  if (x0 > x1) { i=x1; x1=x0; x0=i; }
  p = (Uint8*)super->pixels + y0 * super->pitch + x0 * 4;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  if (sizeof(wchar_t) == sizeof(Uint32)) { wmemset((wchar_t*)p, color, x1-x0+1); } else { i = x1-x0+1; switch( i % 4 ) { do{ case 0: *(Uint32*)p = color; p+=4; case 3: *(Uint32*)p = color; p+=4; case 2: *(Uint32*)p = color; p+=4; case 1: *(Uint32*)p = color; p+=4; }while( (i-=4) > 0 ); } }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 229 "sysc/sdldrawlib.c" 2



static
void Draw_HLine_Init(SDL_Surface *super,
                     Sint16 x0,Sint16 y0, Sint16 x1,
                     Uint32 color)
{
  Draw_Init();
  Draw_HLine(super, x0, y0, x1, color);
}

void (*Draw_HLine)(SDL_Surface *super,
                   Sint16 x0,Sint16 y0, Sint16 x1,
                   Uint32 color) = Draw_HLine_Init;






# 1 "sysc/draw/Draw_VLine.c" 1
# 86 "sysc/draw/Draw_VLine.c"
void Draw_VLine_1(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 y1,
                      Uint32 color)
{






  register Uint8 *p;
  register Sint16 i;

  if (y0 > y1) { i=y1; y1=y0; y0=i; }
  p = (Uint8*)super->pixels + y0 * super->pitch + x0 * 1;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i = y1-y0+1; switch( i % 4 ) { do{ case 0: *p = color; p+=super->pitch; case 3: *p = color; p+=super->pitch; case 2: *p = color; p+=super->pitch; case 1: *p = color; p+=super->pitch; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 251 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_VLine.c" 1
# 86 "sysc/draw/Draw_VLine.c"
void Draw_VLine_2(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 y1,
                      Uint32 color)
{






  register Uint8 *p;
  register Sint16 i;

  if (y0 > y1) { i=y1; y1=y0; y0=i; }
  p = (Uint8*)super->pixels + y0 * super->pitch + x0 * 2;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i = y1-y0+1; switch( i % 4 ) { do{ case 0: *(Uint16*)p = color; p+=super->pitch; case 3: *(Uint16*)p = color; p+=super->pitch; case 2: *(Uint16*)p = color; p+=super->pitch; case 1: *(Uint16*)p = color; p+=super->pitch; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 257 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_VLine.c" 1
# 86 "sysc/draw/Draw_VLine.c"
void Draw_VLine_3(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 y1,
                      Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  register Uint8 *p;
  register Sint16 i;

  if (y0 > y1) { i=y1; y1=y0; y0=i; }
  p = (Uint8*)super->pixels + y0 * super->pitch + x0 * 3;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i = y1-y0+1; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p[0] = colorbyte2; p[1] = colorbyte1; p[2] = colorbyte0; } else { p[0] = colorbyte0; p[1] = colorbyte1; p[2] = colorbyte2; } p+=super->pitch; case 3: if (1234 == 4321) { p[0] = colorbyte2; p[1] = colorbyte1; p[2] = colorbyte0; } else { p[0] = colorbyte0; p[1] = colorbyte1; p[2] = colorbyte2; } p+=super->pitch; case 2: if (1234 == 4321) { p[0] = colorbyte2; p[1] = colorbyte1; p[2] = colorbyte0; } else { p[0] = colorbyte0; p[1] = colorbyte1; p[2] = colorbyte2; } p+=super->pitch; case 1: if (1234 == 4321) { p[0] = colorbyte2; p[1] = colorbyte1; p[2] = colorbyte0; } else { p[0] = colorbyte0; p[1] = colorbyte1; p[2] = colorbyte2; } p+=super->pitch; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 263 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_VLine.c" 1
# 86 "sysc/draw/Draw_VLine.c"
void Draw_VLine_4(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Sint16 y1,
                      Uint32 color)
{






  register Uint8 *p;
  register Sint16 i;

  if (y0 > y1) { i=y1; y1=y0; y0=i; }
  p = (Uint8*)super->pixels + y0 * super->pitch + x0 * 4;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i = y1-y0+1; switch( i % 4 ) { do{ case 0: *(Uint32*)p = color; p+=super->pitch; case 3: *(Uint32*)p = color; p+=super->pitch; case 2: *(Uint32*)p = color; p+=super->pitch; case 1: *(Uint32*)p = color; p+=super->pitch; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 269 "sysc/sdldrawlib.c" 2



static
void Draw_VLine_Init(SDL_Surface *super,
                     Sint16 x0,Sint16 y0, Sint16 y1,
                     Uint32 color)
{
  Draw_Init();
  Draw_VLine(super, x0, y0, y1, color);
}

void (*Draw_VLine)(SDL_Surface *super,
                   Sint16 x0,Sint16 y0, Sint16 y1,
                   Uint32 color) = Draw_VLine_Init;







# 1 "sysc/draw/Draw_Rect.c" 1
# 207 "sysc/draw/Draw_Rect.c"
void Draw_Rect_1(SDL_Surface *super,
                  Sint16 x, Sint16 y, Uint16 w, Uint16 h,
                  Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;

  if (w==0 || h==0) return;

  p0 = (Uint8*)super->pixels + y * super->pitch + x * 1;
  p1 = (Uint8*)super->pixels + (y+h-1) * super->pitch + x * 1;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  memset(p0, color, w); memset(p1, color, w); if (h<3) return; p0 = (Uint8*)super->pixels + (y+1)*super->pitch + x; p1 = (Uint8*)super->pixels + (y+1)*super->pitch + (x+w-1); i = h-2; switch( i % 4 ) { do{ case 0: *p0 = color; p0+=super->pitch; *p1 = color; p1+=super->pitch; case 3: *p0 = color; p0+=super->pitch; *p1 = color; p1+=super->pitch; case 2: *p0 = color; p0+=super->pitch; *p1 = color; p1+=super->pitch; case 1: *p0 = color; p0+=super->pitch; *p1 = color; p1+=super->pitch; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 292 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Rect.c" 1
# 207 "sysc/draw/Draw_Rect.c"
void Draw_Rect_2(SDL_Surface *super,
                  Sint16 x, Sint16 y, Uint16 w, Uint16 h,
                  Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;

  if (w==0 || h==0) return;

  p0 = (Uint8*)super->pixels + y * super->pitch + x * 2;
  p1 = (Uint8*)super->pixels + (y+h-1) * super->pitch + x * 2;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i = w; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; p0+=2; *(Uint16*)p1 = color; p1+=2; case 3: *(Uint16*)p0 = color; p0+=2; *(Uint16*)p1 = color; p1+=2; case 2: *(Uint16*)p0 = color; p0+=2; *(Uint16*)p1 = color; p1+=2; case 1: *(Uint16*)p0 = color; p0+=2; *(Uint16*)p1 = color; p1+=2; }while( (i-=4) > 0 ); } if (h<3) return; p0 = (Uint8*)super->pixels + (y+1)*super->pitch + x*2; p1 = (Uint8*)super->pixels + (y+1)*super->pitch + (x+w-1)*2; i = h-2; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; p0+=super->pitch; *(Uint16*)p1 = color; p1+=super->pitch; case 3: *(Uint16*)p0 = color; p0+=super->pitch; *(Uint16*)p1 = color; p1+=super->pitch; case 2: *(Uint16*)p0 = color; p0+=super->pitch; *(Uint16*)p1 = color; p1+=super->pitch; case 1: *(Uint16*)p0 = color; p0+=super->pitch; *(Uint16*)p1 = color; p1+=super->pitch; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 298 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Rect.c" 1
# 207 "sysc/draw/Draw_Rect.c"
void Draw_Rect_3(SDL_Surface *super,
                  Sint16 x, Sint16 y, Uint16 w, Uint16 h,
                  Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;

  if (w==0 || h==0) return;

  p0 = (Uint8*)super->pixels + y * super->pitch + x * 3;
  p1 = (Uint8*)super->pixels + (y+h-1) * super->pitch + x * 3;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i = w; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; }while( (i-=4) > 0 ); } if (h<3) return; p0 = (Uint8*)super->pixels + (y+1)*super->pitch + x*3; p1 = (Uint8*)super->pixels + (y+1)*super->pitch + (x+w-1)*3; i = h-2; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=super->pitch; p1+=super->pitch; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=super->pitch; p1+=super->pitch; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=super->pitch; p1+=super->pitch; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=super->pitch; p1+=super->pitch; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 304 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Rect.c" 1
# 207 "sysc/draw/Draw_Rect.c"
void Draw_Rect_4(SDL_Surface *super,
                  Sint16 x, Sint16 y, Uint16 w, Uint16 h,
                  Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;

  if (w==0 || h==0) return;

  p0 = (Uint8*)super->pixels + y * super->pitch + x * 4;
  p1 = (Uint8*)super->pixels + (y+h-1) * super->pitch + x * 4;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  if (sizeof(wchar_t) == sizeof(Uint32)) { wmemset((wchar_t*)p0, color, w); wmemset((wchar_t*)p1, color, w); } else { i = w; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; p0+=4; *(Uint32*)p1 = color; p1+=4; case 3: *(Uint32*)p0 = color; p0+=4; *(Uint32*)p1 = color; p1+=4; case 2: *(Uint32*)p0 = color; p0+=4; *(Uint32*)p1 = color; p1+=4; case 1: *(Uint32*)p0 = color; p0+=4; *(Uint32*)p1 = color; p1+=4; }while( (i-=4) > 0 ); } } if (h<3) return; p0 = (Uint8*)super->pixels + (y+1)*super->pitch + x*4; p1 = (Uint8*)super->pixels + (y+1)*super->pitch + (x+w-1)*4; i = h-2; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; p0+=super->pitch; *(Uint32*)p1 = color; p1+=super->pitch; case 3: *(Uint32*)p0 = color; p0+=super->pitch; *(Uint32*)p1 = color; p1+=super->pitch; case 2: *(Uint32*)p0 = color; p0+=super->pitch; *(Uint32*)p1 = color; p1+=super->pitch; case 1: *(Uint32*)p0 = color; p0+=super->pitch; *(Uint32*)p1 = color; p1+=super->pitch; }while( (i-=4) > 0 ); }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 310 "sysc/sdldrawlib.c" 2



static
void Draw_Rect_Init(SDL_Surface *super,
                    Sint16 x,Sint16 y, Uint16 w,Uint16 h,
                    Uint32 color)
{
  Draw_Init();
  Draw_Rect(super, x, y, w, h, color);
}

void (*Draw_Rect)(SDL_Surface *super,
                  Sint16 x,Sint16 y, Uint16 w,Uint16 h,
                  Uint32 color) = Draw_Rect_Init;

void Draw_FillRect(SDL_Surface *super, Sint16 x, Sint16 y, Sint16 w, Sint16 h, Uint32 color)
{
    SDL_Rect r = {x, y, w, h};
    SDL_FillRect(super, &r, color);
}
# 339 "sysc/sdldrawlib.c"
# 1 "sysc/draw/Draw_Ellipse.c" 1
# 57 "sysc/draw/Draw_Ellipse.c"
void Draw_Ellipse_1(SDL_Surface *super,
                      Sint16 x0, Sint16 y0,
                      Uint16 Xradius, Uint16 Yradius,
                      Uint32 color)
{
  Sint32 x, y;
  Sint32 Xchange, Ychange;
  Sint32 EllipseError;
  Sint32 TwoASquare, TwoBSquare;
  Sint32 StoppingX, StoppingY;







  TwoASquare = 2*Xradius*Xradius;
  TwoBSquare = 2*Yradius*Yradius;


  x = Xradius-1;
  y = 0;

  Xchange = Yradius*Yradius*(1-2*Xradius);
  Ychange = Xradius*Xradius;

  EllipseError = 0;

  StoppingX = TwoBSquare*Xradius;
  StoppingY = 0;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }


  while (StoppingX > StoppingY) {

    *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*1)) = color;

    ++y;
    StoppingY += TwoASquare;
    EllipseError += Ychange;
    Ychange += TwoASquare;
    if (( 2*EllipseError + Xchange) > 0) {
      --x;
      StoppingX -= TwoBSquare;
      EllipseError += Xchange;
      Xchange += TwoBSquare;
    }
  }


  x = 0;
  y = Yradius-1;
  Xchange = Yradius*Yradius;
  Ychange = Xradius*Xradius*(1-2*Yradius);
  EllipseError = 0;
  StoppingX = 0;
  StoppingY = TwoASquare*Yradius;


  while (StoppingX < StoppingY) {

    *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*1)) = color;

    ++x;
    StoppingX += TwoBSquare;
    EllipseError += Xchange;
    Xchange += TwoBSquare;
    if ((2*EllipseError + Ychange) > 0) {
      --y;
      StoppingY -= TwoASquare;
      EllipseError += Ychange;
      Ychange += TwoASquare;
    }
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 340 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Ellipse.c" 1
# 57 "sysc/draw/Draw_Ellipse.c"
void Draw_Ellipse_2(SDL_Surface *super,
                      Sint16 x0, Sint16 y0,
                      Uint16 Xradius, Uint16 Yradius,
                      Uint32 color)
{
  Sint32 x, y;
  Sint32 Xchange, Ychange;
  Sint32 EllipseError;
  Sint32 TwoASquare, TwoBSquare;
  Sint32 StoppingX, StoppingY;







  TwoASquare = 2*Xradius*Xradius;
  TwoBSquare = 2*Yradius*Yradius;


  x = Xradius-1;
  y = 0;

  Xchange = Yradius*Yradius*(1-2*Xradius);
  Ychange = Xradius*Xradius;

  EllipseError = 0;

  StoppingX = TwoBSquare*Xradius;
  StoppingY = 0;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }


  while (StoppingX > StoppingY) {

    *((Uint16*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*2)) = color;

    ++y;
    StoppingY += TwoASquare;
    EllipseError += Ychange;
    Ychange += TwoASquare;
    if (( 2*EllipseError + Xchange) > 0) {
      --x;
      StoppingX -= TwoBSquare;
      EllipseError += Xchange;
      Xchange += TwoBSquare;
    }
  }


  x = 0;
  y = Yradius-1;
  Xchange = Yradius*Yradius;
  Ychange = Xradius*Xradius*(1-2*Yradius);
  EllipseError = 0;
  StoppingX = 0;
  StoppingY = TwoASquare*Yradius;


  while (StoppingX < StoppingY) {

    *((Uint16*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*2)) = color;

    ++x;
    StoppingX += TwoBSquare;
    EllipseError += Xchange;
    Xchange += TwoBSquare;
    if ((2*EllipseError + Ychange) > 0) {
      --y;
      StoppingY -= TwoASquare;
      EllipseError += Ychange;
      Ychange += TwoASquare;
    }
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 346 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Ellipse.c" 1
# 57 "sysc/draw/Draw_Ellipse.c"
void Draw_Ellipse_3(SDL_Surface *super,
                      Sint16 x0, Sint16 y0,
                      Uint16 Xradius, Uint16 Yradius,
                      Uint32 color)
{
  Sint32 x, y;
  Sint32 Xchange, Ychange;
  Sint32 EllipseError;
  Sint32 TwoASquare, TwoBSquare;
  Sint32 StoppingX, StoppingY;


  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  TwoASquare = 2*Xradius*Xradius;
  TwoBSquare = 2*Yradius*Yradius;


  x = Xradius-1;
  y = 0;

  Xchange = Yradius*Yradius*(1-2*Xradius);
  Ychange = Xradius*Xradius;

  EllipseError = 0;

  StoppingX = TwoBSquare*Xradius;
  StoppingY = 0;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }


  while (StoppingX > StoppingY) {

    *(0+(1+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte0; }else{ *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte2; }

    ++y;
    StoppingY += TwoASquare;
    EllipseError += Ychange;
    Ychange += TwoASquare;
    if (( 2*EllipseError + Xchange) > 0) {
      --x;
      StoppingX -= TwoBSquare;
      EllipseError += Xchange;
      Xchange += TwoBSquare;
    }
  }


  x = 0;
  y = Yradius-1;
  Xchange = Yradius*Yradius;
  Ychange = Xradius*Xradius*(1-2*Yradius);
  EllipseError = 0;
  StoppingX = 0;
  StoppingY = TwoASquare*Yradius;


  while (StoppingX < StoppingY) {

    *(0+(1+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte0; }else{ *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*3)) = colorbyte2; }

    ++x;
    StoppingX += TwoBSquare;
    EllipseError += Xchange;
    Xchange += TwoBSquare;
    if ((2*EllipseError + Ychange) > 0) {
      --y;
      StoppingY -= TwoASquare;
      EllipseError += Ychange;
      Ychange += TwoASquare;
    }
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 352 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Ellipse.c" 1
# 57 "sysc/draw/Draw_Ellipse.c"
void Draw_Ellipse_4(SDL_Surface *super,
                      Sint16 x0, Sint16 y0,
                      Uint16 Xradius, Uint16 Yradius,
                      Uint32 color)
{
  Sint32 x, y;
  Sint32 Xchange, Ychange;
  Sint32 EllipseError;
  Sint32 TwoASquare, TwoBSquare;
  Sint32 StoppingX, StoppingY;







  TwoASquare = 2*Xradius*Xradius;
  TwoBSquare = 2*Yradius*Yradius;


  x = Xradius-1;
  y = 0;

  Xchange = Yradius*Yradius*(1-2*Xradius);
  Ychange = Xradius*Xradius;

  EllipseError = 0;

  StoppingX = TwoBSquare*Xradius;
  StoppingY = 0;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }


  while (StoppingX > StoppingY) {

    *((Uint32*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*4)) = color;

    ++y;
    StoppingY += TwoASquare;
    EllipseError += Ychange;
    Ychange += TwoASquare;
    if (( 2*EllipseError + Xchange) > 0) {
      --x;
      StoppingX -= TwoBSquare;
      EllipseError += Xchange;
      Xchange += TwoBSquare;
    }
  }


  x = 0;
  y = Yradius-1;
  Xchange = Yradius*Yradius;
  Ychange = Xradius*Xradius*(1-2*Yradius);
  EllipseError = 0;
  StoppingX = 0;
  StoppingY = TwoASquare*Yradius;


  while (StoppingX < StoppingY) {

    *((Uint32*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0+x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0+x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0+y)*super->pitch + (x0-x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (y0-y)*super->pitch + (x0-x)*4)) = color;

    ++x;
    StoppingX += TwoBSquare;
    EllipseError += Xchange;
    Xchange += TwoBSquare;
    if ((2*EllipseError + Ychange) > 0) {
      --y;
      StoppingY -= TwoASquare;
      EllipseError += Ychange;
      Ychange += TwoASquare;
    }
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 358 "sysc/sdldrawlib.c" 2



static
void Draw_Ellipse_Init(SDL_Surface *super,
                       Sint16 x0, Sint16 y0,
                       Uint16 Xradius, Uint16 Yradius,
                       Uint32 color)
{
  Draw_Init();
  Draw_Ellipse(super, x0, y0, Xradius, Yradius, color);
}


void (*Draw_Ellipse)(SDL_Surface *super,
                     Sint16 x0, Sint16 y0,
                     Uint16 Xradius, Uint16 Yradius,
                     Uint32 color) = Draw_Ellipse_Init;







# 1 "sysc/draw/Draw_FillEllipse.c" 1
# 129 "sysc/draw/Draw_FillEllipse.c"
void Draw_FillEllipse_1(SDL_Surface *super,
                      Sint16 x0, Sint16 y0,
                      Uint16 Xradius, Uint16 Yradius,
                      Uint32 color)
{
# 146 "sysc/draw/Draw_FillEllipse.c"
  Sint32 x, y;
  Sint32 Xchange, Ychange;
  Sint32 EllipseError;
  Sint32 TwoASquare, TwoBSquare;
  Sint32 StoppingX, StoppingY;

  TwoASquare = 2*Xradius*Xradius;
  TwoBSquare = 2*Yradius*Yradius;


  x = Xradius-1;
  y = 0;

  Xchange = Yradius*Yradius*(1-2*Xradius);
  Ychange = Xradius*Xradius;

  EllipseError = 0;

  StoppingX = TwoBSquare*Xradius;
  StoppingY = 0;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }


  while (StoppingX > StoppingY) {

    memset(((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)), color, 2*x+1); memset(((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)), color, 2*x+1);

    ++y;
    StoppingY += TwoASquare;
    EllipseError += Ychange;
    Ychange += TwoASquare;
    if (( 2*EllipseError + Xchange) > 0) {
      --x;
      StoppingX -= TwoBSquare;
      EllipseError += Xchange;
      Xchange += TwoBSquare;
    }
  }


  x = 0;
  y = Yradius-1;
  Xchange = Yradius*Yradius;
  Ychange = Xradius*Xradius*(1-2*Yradius);
  EllipseError = 0;
  StoppingX = 0;
  StoppingY = TwoASquare*Yradius;


  while (StoppingX < StoppingY) {

    memset(((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)), color, 2*x+1); memset(((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)), color, 2*x+1);

    ++x;
    StoppingX += TwoBSquare;
    EllipseError += Xchange;
    Xchange += TwoBSquare;
    if ((2*EllipseError + Ychange) > 0) {
      --y;
      StoppingY -= TwoASquare;
      EllipseError += Ychange;
      Ychange += TwoASquare;
    }
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 384 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillEllipse.c" 1
# 129 "sysc/draw/Draw_FillEllipse.c"
void Draw_FillEllipse_2(SDL_Surface *super,
                      Sint16 x0, Sint16 y0,
                      Uint16 Xradius, Uint16 Yradius,
                      Uint32 color)
{







  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;


  Sint32 x, y;
  Sint32 Xchange, Ychange;
  Sint32 EllipseError;
  Sint32 TwoASquare, TwoBSquare;
  Sint32 StoppingX, StoppingY;

  TwoASquare = 2*Xradius*Xradius;
  TwoBSquare = 2*Yradius*Yradius;


  x = Xradius-1;
  y = 0;

  Xchange = Yradius*Yradius*(1-2*Xradius);
  Ychange = Xradius*Xradius;

  EllipseError = 0;

  StoppingX = TwoBSquare*Xradius;
  StoppingY = 0;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }


  while (StoppingX > StoppingY) {

    { p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*2); p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*2); i = 2*x+1; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 3: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 2: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 1: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; }while( (i-=4) > 0 ); } }

    ++y;
    StoppingY += TwoASquare;
    EllipseError += Ychange;
    Ychange += TwoASquare;
    if (( 2*EllipseError + Xchange) > 0) {
      --x;
      StoppingX -= TwoBSquare;
      EllipseError += Xchange;
      Xchange += TwoBSquare;
    }
  }


  x = 0;
  y = Yradius-1;
  Xchange = Yradius*Yradius;
  Ychange = Xradius*Xradius*(1-2*Yradius);
  EllipseError = 0;
  StoppingX = 0;
  StoppingY = TwoASquare*Yradius;


  while (StoppingX < StoppingY) {

    { p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*2); p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*2); i = 2*x+1; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 3: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 2: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 1: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; }while( (i-=4) > 0 ); } }

    ++x;
    StoppingX += TwoBSquare;
    EllipseError += Xchange;
    Xchange += TwoBSquare;
    if ((2*EllipseError + Ychange) > 0) {
      --y;
      StoppingY -= TwoASquare;
      EllipseError += Ychange;
      Ychange += TwoASquare;
    }
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 390 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillEllipse.c" 1
# 129 "sysc/draw/Draw_FillEllipse.c"
void Draw_FillEllipse_3(SDL_Surface *super,
                      Sint16 x0, Sint16 y0,
                      Uint16 Xradius, Uint16 Yradius,
                      Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);



  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;


  Sint32 x, y;
  Sint32 Xchange, Ychange;
  Sint32 EllipseError;
  Sint32 TwoASquare, TwoBSquare;
  Sint32 StoppingX, StoppingY;

  TwoASquare = 2*Xradius*Xradius;
  TwoBSquare = 2*Yradius*Yradius;


  x = Xradius-1;
  y = 0;

  Xchange = Yradius*Yradius*(1-2*Xradius);
  Ychange = Xradius*Xradius;

  EllipseError = 0;

  StoppingX = TwoBSquare*Xradius;
  StoppingY = 0;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }


  while (StoppingX > StoppingY) {

    { p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*3); p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*3); i = 2*x+1; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; }while( (i-=4) > 0 ); } }

    ++y;
    StoppingY += TwoASquare;
    EllipseError += Ychange;
    Ychange += TwoASquare;
    if (( 2*EllipseError + Xchange) > 0) {
      --x;
      StoppingX -= TwoBSquare;
      EllipseError += Xchange;
      Xchange += TwoBSquare;
    }
  }


  x = 0;
  y = Yradius-1;
  Xchange = Yradius*Yradius;
  Ychange = Xradius*Xradius*(1-2*Yradius);
  EllipseError = 0;
  StoppingX = 0;
  StoppingY = TwoASquare*Yradius;


  while (StoppingX < StoppingY) {

    { p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*3); p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*3); i = 2*x+1; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; }while( (i-=4) > 0 ); } }

    ++x;
    StoppingX += TwoBSquare;
    EllipseError += Xchange;
    Xchange += TwoBSquare;
    if ((2*EllipseError + Ychange) > 0) {
      --y;
      StoppingY -= TwoASquare;
      EllipseError += Ychange;
      Ychange += TwoASquare;
    }
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 396 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillEllipse.c" 1
# 129 "sysc/draw/Draw_FillEllipse.c"
void Draw_FillEllipse_4(SDL_Surface *super,
                      Sint16 x0, Sint16 y0,
                      Uint16 Xradius, Uint16 Yradius,
                      Uint32 color)
{







  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;


  Sint32 x, y;
  Sint32 Xchange, Ychange;
  Sint32 EllipseError;
  Sint32 TwoASquare, TwoBSquare;
  Sint32 StoppingX, StoppingY;

  TwoASquare = 2*Xradius*Xradius;
  TwoBSquare = 2*Yradius*Yradius;


  x = Xradius-1;
  y = 0;

  Xchange = Yradius*Yradius*(1-2*Xradius);
  Ychange = Xradius*Xradius;

  EllipseError = 0;

  StoppingX = TwoBSquare*Xradius;
  StoppingY = 0;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }


  while (StoppingX > StoppingY) {

    if (sizeof(wchar_t) == sizeof(Uint32)) { wmemset( (wchar_t*)((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*4), color, 2*x+1); wmemset( (wchar_t*)((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*4), color, 2*x+1); } else { p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*4); p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*4); i = 2*x+1; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 3: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 2: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 1: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; }while( (i-=4) > 0 ); } }

    ++y;
    StoppingY += TwoASquare;
    EllipseError += Ychange;
    Ychange += TwoASquare;
    if (( 2*EllipseError + Xchange) > 0) {
      --x;
      StoppingX -= TwoBSquare;
      EllipseError += Xchange;
      Xchange += TwoBSquare;
    }
  }


  x = 0;
  y = Yradius-1;
  Xchange = Yradius*Yradius;
  Ychange = Xradius*Xradius*(1-2*Yradius);
  EllipseError = 0;
  StoppingX = 0;
  StoppingY = TwoASquare*Yradius;


  while (StoppingX < StoppingY) {

    if (sizeof(wchar_t) == sizeof(Uint32)) { wmemset( (wchar_t*)((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*4), color, 2*x+1); wmemset( (wchar_t*)((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*4), color, 2*x+1); } else { p0 = ((Uint8*)super->pixels+ (y0+y)*super->pitch+ (x0-x)*4); p1 = ((Uint8*)super->pixels+ (y0-y)*super->pitch+ (x0-x)*4); i = 2*x+1; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 3: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 2: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 1: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; }while( (i-=4) > 0 ); } }

    ++x;
    StoppingX += TwoBSquare;
    EllipseError += Xchange;
    Xchange += TwoBSquare;
    if ((2*EllipseError + Ychange) > 0) {
      --y;
      StoppingY -= TwoASquare;
      EllipseError += Ychange;
      Ychange += TwoASquare;
    }
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 402 "sysc/sdldrawlib.c" 2



static
void Draw_FillEllipse_Init(SDL_Surface *super,
                           Sint16 x0, Sint16 y0,
                           Uint16 Xradius, Uint16 Yradius,
                           Uint32 color)
{
  Draw_Init();
  Draw_FillEllipse(super, x0, y0, Xradius, Yradius, color);
}


void (*Draw_FillEllipse)(SDL_Surface *super,
                         Sint16 x0, Sint16 y0,
                         Uint16 Xradius, Uint16 Yradius,
                         Uint32 color) = Draw_FillEllipse_Init;







# 1 "sysc/draw/Draw_Round.c" 1
# 250 "sysc/draw/Draw_Round.c"
void Draw_Round_1(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                      Uint16 corner, Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;
  Sint16 dx, dy;

  Sint16 Xcenter, Ycenter, X2center, Y2center;

  Sint16 x = 0;
  Sint16 rightInc = 6;
  Sint16 d, diagonalInc;

  if (w==0 || h==0) return;


  if (corner!=0) {
    d = w<h ? w : h;
    --corner;
    if (corner!=0 && corner+2 >= d ) {
      if (corner+2 == d) --corner;
      else corner = 0;
    }
  }

  d = 3 - (corner<<1);
  diagonalInc = 10 - (corner<<2);


  dx = w - (corner<<1);
  Xcenter = x0+corner;
  dy = h - (corner<<1);
  Ycenter = y0+corner;


  X2center=Xcenter+dx-1;
  Y2center=Ycenter+dy-1;

  p0 = (Uint8*)super->pixels + y0 * super->pitch + Xcenter*1;
  p1 = (Uint8*)super->pixels + (y0+h-1) * super->pitch + Xcenter*1;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  memset(p0, color, dx); memset(p1, color, dx); if (h<3) return; p0 = (Uint8*)super->pixels + Ycenter*super->pitch + x0; p1 = (Uint8*)super->pixels + Ycenter*super->pitch + x0+w-1; i=dy; switch( i % 4 ) { do{ case 0: *p0 = color; p0+=super->pitch; *p1 = color; p1+=super->pitch; case 3: *p0 = color; p0+=super->pitch; *p1 = color; p1+=super->pitch; case 2: *p0 = color; p0+=super->pitch; *p1 = color; p1+=super->pitch; case 1: *p0 = color; p0+=super->pitch; *p1 = color; p1+=super->pitch; }while( (i-=4) > 0 ); }

  while (x < corner) {

    *(0+(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (Xcenter - corner)*1)) = color; *(0+(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (Xcenter - x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (X2center + x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (X2center + corner)*1)) = color; *(0+(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (X2center + x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (X2center + corner)*1)) = color; *(0+(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (Xcenter - x)*1)) = color; *(0+(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (Xcenter - corner)*1)) = color;

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      --corner;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    ++x;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 428 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Round.c" 1
# 250 "sysc/draw/Draw_Round.c"
void Draw_Round_2(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                      Uint16 corner, Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;
  Sint16 dx, dy;

  Sint16 Xcenter, Ycenter, X2center, Y2center;

  Sint16 x = 0;
  Sint16 rightInc = 6;
  Sint16 d, diagonalInc;

  if (w==0 || h==0) return;


  if (corner!=0) {
    d = w<h ? w : h;
    --corner;
    if (corner!=0 && corner+2 >= d ) {
      if (corner+2 == d) --corner;
      else corner = 0;
    }
  }

  d = 3 - (corner<<1);
  diagonalInc = 10 - (corner<<2);


  dx = w - (corner<<1);
  Xcenter = x0+corner;
  dy = h - (corner<<1);
  Ycenter = y0+corner;


  X2center=Xcenter+dx-1;
  Y2center=Ycenter+dy-1;

  p0 = (Uint8*)super->pixels + y0 * super->pitch + Xcenter*2;
  p1 = (Uint8*)super->pixels + (y0+h-1) * super->pitch + Xcenter*2;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i=dx; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; p0+=2; *(Uint16*)p1 = color; p1+=2; case 3: *(Uint16*)p0 = color; p0+=2; *(Uint16*)p1 = color; p1+=2; case 2: *(Uint16*)p0 = color; p0+=2; *(Uint16*)p1 = color; p1+=2; case 1: *(Uint16*)p0 = color; p0+=2; *(Uint16*)p1 = color; p1+=2; }while( (i-=4) > 0 ); } if (h<3) return; p0 = (Uint8*)super->pixels + Ycenter*super->pitch + x0*2; p1 = (Uint8*)super->pixels + Ycenter*super->pitch + (x0+w-1)*2; i=dy; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; p0+=super->pitch; *(Uint16*)p1 = color; p1+=super->pitch; case 3: *(Uint16*)p0 = color; p0+=super->pitch; *(Uint16*)p1 = color; p1+=super->pitch; case 2: *(Uint16*)p0 = color; p0+=super->pitch; *(Uint16*)p1 = color; p1+=super->pitch; case 1: *(Uint16*)p0 = color; p0+=super->pitch; *(Uint16*)p1 = color; p1+=super->pitch; }while( (i-=4) > 0 ); }

  while (x < corner) {

    *((Uint16*)(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (Xcenter - corner)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (Xcenter - x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (X2center + x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (X2center + corner)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (X2center + x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (X2center + corner)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (Xcenter - x)*2)) = color; *((Uint16*)(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (Xcenter - corner)*2)) = color;

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      --corner;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    ++x;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 434 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Round.c" 1
# 250 "sysc/draw/Draw_Round.c"
void Draw_Round_3(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                      Uint16 corner, Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;
  Sint16 dx, dy;

  Sint16 Xcenter, Ycenter, X2center, Y2center;

  Sint16 x = 0;
  Sint16 rightInc = 6;
  Sint16 d, diagonalInc;

  if (w==0 || h==0) return;


  if (corner!=0) {
    d = w<h ? w : h;
    --corner;
    if (corner!=0 && corner+2 >= d ) {
      if (corner+2 == d) --corner;
      else corner = 0;
    }
  }

  d = 3 - (corner<<1);
  diagonalInc = 10 - (corner<<2);


  dx = w - (corner<<1);
  Xcenter = x0+corner;
  dy = h - (corner<<1);
  Ycenter = y0+corner;


  X2center=Xcenter+dx-1;
  Y2center=Ycenter+dy-1;

  p0 = (Uint8*)super->pixels + y0 * super->pitch + Xcenter*3;
  p1 = (Uint8*)super->pixels + (y0+h-1) * super->pitch + Xcenter*3;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  i=dx; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; }while( (i-=4) > 0 ); } if (h<3) return; p0 = (Uint8*)super->pixels + Ycenter*super->pitch + x0*3; p1 = (Uint8*)super->pixels + Ycenter*super->pitch + (x0+w-1)*3; i=dy; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=super->pitch; p1+=super->pitch; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=super->pitch; p1+=super->pitch; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=super->pitch; p1+=super->pitch; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=super->pitch; p1+=super->pitch; }while( (i-=4) > 0 ); }

  while (x < corner) {

    *(0+(1+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (Xcenter - corner)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (Xcenter - x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (X2center + x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (X2center + corner)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (X2center + x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (X2center + corner)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (Xcenter - x)*3)) = colorbyte1; *(0+(1+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (Xcenter - corner)*3)) = colorbyte1; if (1234 == 4321) { *(0+(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (Xcenter - corner)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (Xcenter - x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (X2center + x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (X2center + corner)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (X2center + x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (X2center + corner)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (Xcenter - x)*3)) = colorbyte2; *(0+(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (Xcenter - corner)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (Xcenter - corner)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (Xcenter - x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (X2center + x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (X2center + corner)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (X2center + x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (X2center + corner)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (Xcenter - x)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (Xcenter - corner)*3)) = colorbyte0; }else{ *(0+(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (Xcenter - corner)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (Xcenter - x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (X2center + x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (X2center + corner)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (X2center + x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (X2center + corner)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (Xcenter - x)*3)) = colorbyte0; *(0+(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (Xcenter - corner)*3)) = colorbyte0; *(0+(2+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (Xcenter - corner)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (Xcenter - x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (X2center + x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (X2center + corner)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (X2center + x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (X2center + corner)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (Xcenter - x)*3)) = colorbyte2; *(0+(2+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (Xcenter - corner)*3)) = colorbyte2; }

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      --corner;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    ++x;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 440 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_Round.c" 1
# 250 "sysc/draw/Draw_Round.c"
void Draw_Round_4(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                      Uint16 corner, Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;
  register Sint16 i;
  Sint16 dx, dy;

  Sint16 Xcenter, Ycenter, X2center, Y2center;

  Sint16 x = 0;
  Sint16 rightInc = 6;
  Sint16 d, diagonalInc;

  if (w==0 || h==0) return;


  if (corner!=0) {
    d = w<h ? w : h;
    --corner;
    if (corner!=0 && corner+2 >= d ) {
      if (corner+2 == d) --corner;
      else corner = 0;
    }
  }

  d = 3 - (corner<<1);
  diagonalInc = 10 - (corner<<2);


  dx = w - (corner<<1);
  Xcenter = x0+corner;
  dy = h - (corner<<1);
  Ycenter = y0+corner;


  X2center=Xcenter+dx-1;
  Y2center=Ycenter+dy-1;

  p0 = (Uint8*)super->pixels + y0 * super->pitch + Xcenter*4;
  p1 = (Uint8*)super->pixels + (y0+h-1) * super->pitch + Xcenter*4;


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  if (sizeof(wchar_t) == sizeof(Uint32)) { wmemset((wchar_t*)p0, color, dx); wmemset((wchar_t*)p1, color, dx); } else { i=dx; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; p0+=4; *(Uint32*)p1 = color; p1+=4; case 3: *(Uint32*)p0 = color; p0+=4; *(Uint32*)p1 = color; p1+=4; case 2: *(Uint32*)p0 = color; p0+=4; *(Uint32*)p1 = color; p1+=4; case 1: *(Uint32*)p0 = color; p0+=4; *(Uint32*)p1 = color; p1+=4; }while( (i-=4) > 0 ); } } if (h<3) return; p0 = (Uint8*)super->pixels + Ycenter*super->pitch + x0*4; p1 = (Uint8*)super->pixels + Ycenter*super->pitch + (x0+w-1)*4; i=dy; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; p0+=super->pitch; *(Uint32*)p1 = color; p1+=super->pitch; case 3: *(Uint32*)p0 = color; p0+=super->pitch; *(Uint32*)p1 = color; p1+=super->pitch; case 2: *(Uint32*)p0 = color; p0+=super->pitch; *(Uint32*)p1 = color; p1+=super->pitch; case 1: *(Uint32*)p0 = color; p0+=super->pitch; *(Uint32*)p1 = color; p1+=super->pitch; }while( (i-=4) > 0 ); }

  while (x < corner) {

    *((Uint32*)(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (Xcenter - corner)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (Xcenter - x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (Ycenter-corner)*super->pitch + (X2center + x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (Ycenter-x)*super->pitch + (X2center + corner)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (X2center + x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (X2center + corner)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (Y2center+corner)*super->pitch + (Xcenter - x)*4)) = color; *((Uint32*)(0+(Uint8*)super->pixels + (Y2center+x)*super->pitch + (Xcenter - corner)*4)) = color;

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      --corner;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    ++x;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 446 "sysc/sdldrawlib.c" 2



static
void Draw_Round_Init(SDL_Surface *super,
                     Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                     Uint16 corner, Uint32 color)
{
  Draw_Init();
  Draw_Round(super, x0, y0, w, h, corner, color);
}

void (*Draw_Round)(SDL_Surface *super,
                   Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                   Uint16 corner, Uint32 color) = Draw_Round_Init;







# 1 "sysc/draw/Draw_FillRound.c" 1
# 165 "sysc/draw/Draw_FillRound.c"
void Draw_FillRound_1(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                      Uint16 corner, Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;



  Sint16 dx, dy;

  Sint16 Xcenter, Ycenter, X2center, Y2center;

  Sint16 x = 0;
  Sint16 rightInc = 6;
  Sint16 d, diagonalInc;

  SDL_Rect r;


  if (w==0 || h==0) return;


  if (corner!=0) {
    d = w<h ? w : h;
    --corner;
    if (corner!=0 && corner+2 >= d ) {
      if (corner+2 == d) --corner;
      else corner = 0;
    }
  }

  d = 3 - (corner<<1);
  diagonalInc = 10 - (corner<<2);


  dx = w - (corner<<1);
  Xcenter = x0+corner;
  dy = h - (corner<<1);
  Ycenter = y0+corner;


  X2center=Xcenter+dx-1;
  Y2center=Ycenter+dy-1;

  r.x = x0; r.y = Ycenter;
  r.w = w; r.h = dy;
  SDL_FillRect(super, &r, color);


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x < corner) {

    p0 = ((Uint8*)super->pixels+(Ycenter-x)*super->pitch +
                                       (Xcenter-corner)*1);
    p1 = ((Uint8*)super->pixels+(Y2center+x)*super->pitch +
                                        (Xcenter-corner)*1);

    memset(p0, color, X2center - Xcenter + 2*corner+1); memset(p1, color, X2center - Xcenter + 2*corner+1); p0 = ((Uint8*)super->pixels+(Y2center+corner)*super->pitch+(Xcenter-x)); p1 = ((Uint8*)super->pixels+(Ycenter-corner)*super->pitch +(Xcenter-x)); memset(p0, color, X2center - Xcenter + 2*x+1); memset(p1, color, X2center - Xcenter + 2*x+1);

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      --corner;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    ++x;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 469 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillRound.c" 1
# 165 "sysc/draw/Draw_FillRound.c"
void Draw_FillRound_2(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                      Uint16 corner, Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;

  register Sint16 i;

  Sint16 dx, dy;

  Sint16 Xcenter, Ycenter, X2center, Y2center;

  Sint16 x = 0;
  Sint16 rightInc = 6;
  Sint16 d, diagonalInc;

  SDL_Rect r;


  if (w==0 || h==0) return;


  if (corner!=0) {
    d = w<h ? w : h;
    --corner;
    if (corner!=0 && corner+2 >= d ) {
      if (corner+2 == d) --corner;
      else corner = 0;
    }
  }

  d = 3 - (corner<<1);
  diagonalInc = 10 - (corner<<2);


  dx = w - (corner<<1);
  Xcenter = x0+corner;
  dy = h - (corner<<1);
  Ycenter = y0+corner;


  X2center=Xcenter+dx-1;
  Y2center=Ycenter+dy-1;

  r.x = x0; r.y = Ycenter;
  r.w = w; r.h = dy;
  SDL_FillRect(super, &r, color);


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x < corner) {

    p0 = ((Uint8*)super->pixels+(Ycenter-x)*super->pitch +
                                       (Xcenter-corner)*2);
    p1 = ((Uint8*)super->pixels+(Y2center+x)*super->pitch +
                                        (Xcenter-corner)*2);

    i = X2center - Xcenter + 2*corner+1; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 3: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 2: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 1: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; }while( (i-=4) > 0 ); } p0 = ((Uint8*)super->pixels+(Y2center+corner)*super->pitch+(Xcenter-x)*2); p1 = ((Uint8*)super->pixels+(Ycenter-corner)*super->pitch +(Xcenter-x)*2); i = X2center - Xcenter + 2*x+1; switch( i % 4 ) { do{ case 0: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 3: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 2: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; case 1: *(Uint16*)p0 = color; *(Uint16*)p1 = color; p0+=2; p1+=2; }while( (i-=4) > 0 ); }

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      --corner;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    ++x;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 475 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillRound.c" 1
# 165 "sysc/draw/Draw_FillRound.c"
void Draw_FillRound_3(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                      Uint16 corner, Uint32 color)
{

  Uint8 colorbyte0 = (Uint8) (color & 0xff);
  Uint8 colorbyte1 = (Uint8) ((color >> 8) & 0xff);
  Uint8 colorbyte2 = (Uint8) ((color >> 16) & 0xff);


  register Uint8 *p0;
  register Uint8 *p1;

  register Sint16 i;

  Sint16 dx, dy;

  Sint16 Xcenter, Ycenter, X2center, Y2center;

  Sint16 x = 0;
  Sint16 rightInc = 6;
  Sint16 d, diagonalInc;

  SDL_Rect r;


  if (w==0 || h==0) return;


  if (corner!=0) {
    d = w<h ? w : h;
    --corner;
    if (corner!=0 && corner+2 >= d ) {
      if (corner+2 == d) --corner;
      else corner = 0;
    }
  }

  d = 3 - (corner<<1);
  diagonalInc = 10 - (corner<<2);


  dx = w - (corner<<1);
  Xcenter = x0+corner;
  dy = h - (corner<<1);
  Ycenter = y0+corner;


  X2center=Xcenter+dx-1;
  Y2center=Ycenter+dy-1;

  r.x = x0; r.y = Ycenter;
  r.w = w; r.h = dy;
  SDL_FillRect(super, &r, color);


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x < corner) {

    p0 = ((Uint8*)super->pixels+(Ycenter-x)*super->pitch +
                                       (Xcenter-corner)*3);
    p1 = ((Uint8*)super->pixels+(Y2center+x)*super->pitch +
                                        (Xcenter-corner)*3);

    i = X2center - Xcenter + 2*corner+1; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; }while( (i-=4) > 0 ); } p0 = ((Uint8*)super->pixels+(Y2center+corner)*super->pitch+(Xcenter-x)*3); p1 = ((Uint8*)super->pixels+(Ycenter-corner)*super->pitch +(Xcenter-x)*3); i = X2center - Xcenter + 2*x+1; switch( i % 4 ) { do{ case 0: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 3: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 2: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; case 1: if (1234 == 4321) { p0[0] = colorbyte2; p0[1] = colorbyte1; p0[2] = colorbyte0; p1[0] = colorbyte2; p1[1] = colorbyte1; p1[2] = colorbyte0; } else { p0[0] = colorbyte0; p0[1] = colorbyte1; p0[2] = colorbyte2; p1[0] = colorbyte0; p1[1] = colorbyte1; p1[2] = colorbyte2; } p0+=3; p1+=3; }while( (i-=4) > 0 ); }

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      --corner;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    ++x;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 481 "sysc/sdldrawlib.c" 2





# 1 "sysc/draw/Draw_FillRound.c" 1
# 165 "sysc/draw/Draw_FillRound.c"
void Draw_FillRound_4(SDL_Surface *super,
                      Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                      Uint16 corner, Uint32 color)
{






  register Uint8 *p0;
  register Uint8 *p1;

  register Sint16 i;

  Sint16 dx, dy;

  Sint16 Xcenter, Ycenter, X2center, Y2center;

  Sint16 x = 0;
  Sint16 rightInc = 6;
  Sint16 d, diagonalInc;

  SDL_Rect r;


  if (w==0 || h==0) return;


  if (corner!=0) {
    d = w<h ? w : h;
    --corner;
    if (corner!=0 && corner+2 >= d ) {
      if (corner+2 == d) --corner;
      else corner = 0;
    }
  }

  d = 3 - (corner<<1);
  diagonalInc = 10 - (corner<<2);


  dx = w - (corner<<1);
  Xcenter = x0+corner;
  dy = h - (corner<<1);
  Ycenter = y0+corner;


  X2center=Xcenter+dx-1;
  Y2center=Ycenter+dy-1;

  r.x = x0; r.y = Ycenter;
  r.w = w; r.h = dy;
  SDL_FillRect(super, &r, color);


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) {
      if (SDL_LockSurface(super) < 0) { return; }
  }

  while (x < corner) {

    p0 = ((Uint8*)super->pixels+(Ycenter-x)*super->pitch +
                                       (Xcenter-corner)*4);
    p1 = ((Uint8*)super->pixels+(Y2center+x)*super->pitch +
                                        (Xcenter-corner)*4);

    if (sizeof(wchar_t) == sizeof(Uint32)) { wmemset((wchar_t*)p0, color, X2center - Xcenter + 2*corner+1); wmemset((wchar_t*)p1, color, X2center - Xcenter + 2*corner+1); p0 = ((Uint8*)super->pixels+(Y2center+corner)*super->pitch+(Xcenter-x)*4); p1 = ((Uint8*)super->pixels+(Ycenter-corner)*super->pitch +(Xcenter-x)*4); wmemset((wchar_t*)p0, color, X2center - Xcenter + 2*x+1); wmemset((wchar_t*)p1, color, X2center - Xcenter + 2*x+1); } else { i = X2center - Xcenter + 2*corner+1; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 3: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 2: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 1: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; }while( (i-=4) > 0 ); } p0 = ((Uint8*)super->pixels+(Y2center+corner)*super->pitch+(Xcenter-x)*4); p1 = ((Uint8*)super->pixels+(Ycenter-corner)*super->pitch +(Xcenter-x)*4); i = X2center - Xcenter + 2*x+1; switch( i % 4 ) { do{ case 0: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 3: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 2: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; case 1: *(Uint32*)p0 = color; *(Uint32*)p1 = color; p0+=4; p1+=4; }while( (i-=4) > 0 ); } }

    if (d >= 0) {
      d += diagonalInc;
      diagonalInc += 8;
      --corner;
    } else {
      d += rightInc;
      diagonalInc += 4;
    }
    rightInc += 4;
    ++x;
  }


  if ((super->offset || ((super->flags & (0x00000001|0x00000004|0x00004000)) != 0))) { SDL_UnlockSurface(super); }

}
# 487 "sysc/sdldrawlib.c" 2



static
void Draw_FillRound_Init(SDL_Surface *super,
                         Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                         Uint16 corner, Uint32 color)
{
  Draw_Init();
  Draw_FillRound(super, x0, y0, w, h, corner, color);
}

void (*Draw_FillRound)(SDL_Surface *super,
                       Sint16 x0,Sint16 y0, Uint16 w,Uint16 h,
                       Uint16 corner, Uint32 color) = Draw_FillRound_Init;
# 520 "sysc/sdldrawlib.c"
static
void Draw_Init(void)
{
  SDL_Surface *screen = SDL_GetVideoSurface();
  if (!screen) {
    fprintf(stderr,"SDL_draw: SDL_Draw_Init ERROR!!."
                  " Video Surface not found\n");
    exit(-2);
  }


  SDL_Delay(1000);

  switch(screen->format->BytesPerPixel) {
    case 1:

      Draw_Pixel = Draw_Pixel_1; Draw_Line = Draw_Line_1; Draw_Circle = Draw_Circle_1; Draw_FillCircle = Draw_FillCircle_1; Draw_HLine = Draw_HLine_1; Draw_VLine = Draw_VLine_1; Draw_Rect = Draw_Rect_1; Draw_Ellipse = Draw_Ellipse_1; Draw_FillEllipse = Draw_FillEllipse_1; Draw_Round = Draw_Round_1; Draw_FillRound = Draw_FillRound_1;
    break;

    case 2:

      Draw_Pixel = Draw_Pixel_2; Draw_Line = Draw_Line_2; Draw_Circle = Draw_Circle_2; Draw_FillCircle = Draw_FillCircle_2; Draw_HLine = Draw_HLine_2; Draw_VLine = Draw_VLine_2; Draw_Rect = Draw_Rect_2; Draw_Ellipse = Draw_Ellipse_2; Draw_FillEllipse = Draw_FillEllipse_2; Draw_Round = Draw_Round_2; Draw_FillRound = Draw_FillRound_2;
    break;

    case 3:

      Draw_Pixel = Draw_Pixel_3; Draw_Line = Draw_Line_3; Draw_Circle = Draw_Circle_3; Draw_FillCircle = Draw_FillCircle_3; Draw_HLine = Draw_HLine_3; Draw_VLine = Draw_VLine_3; Draw_Rect = Draw_Rect_3; Draw_Ellipse = Draw_Ellipse_3; Draw_FillEllipse = Draw_FillEllipse_3; Draw_Round = Draw_Round_3; Draw_FillRound = Draw_FillRound_3;
    break;

    case 4:

      Draw_Pixel = Draw_Pixel_4; Draw_Line = Draw_Line_4; Draw_Circle = Draw_Circle_4; Draw_FillCircle = Draw_FillCircle_4; Draw_HLine = Draw_HLine_4; Draw_VLine = Draw_VLine_4; Draw_Rect = Draw_Rect_4; Draw_Ellipse = Draw_Ellipse_4; Draw_FillEllipse = Draw_FillEllipse_4; Draw_Round = Draw_Round_4; Draw_FillRound = Draw_FillRound_4;
    break;
  }

}
