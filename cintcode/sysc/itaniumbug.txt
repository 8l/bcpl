This document is evidence for a possible bug in the C compiler
(HP C++ V7.2-018) for an Itanium HP rx2660  (1.59GHz/6.0MB)
running under Open VMS.

by

Martin Richards
6 June 2013

This is long and somewhat subtle, but I believe it demonstrates a
repeatable bug in the compiled code for the Itanium using the C++
compiler under Open CMS.

The fault is present when the compiler option optimize=(level=2) is
given but not for level 0 or 1, but these generate code that runs
about 5 times slower.



For many months I have had a version of the BCPL Cintcode System
running successfully on a Itanium.  This system uses a byte stream
interpreter written in C to execute the compiled Cintcode generated by
the BCPL compiler. Within the compiler there is a SWITCHON command in
the lexical analyser (lex) that switches on the next character of
input. This compiles into a label vector switch in Cintcode using the
SWL opcode. The C code to handle the SWL opcode is as follows:

//  561 :   case F_swl: { BCPLWORD n,q;
//  562 :                 q = (pc+1)>>1;
//  563 :                 n = H[q++];
//  564 :                 if(0<=a && a<n) q += a + 1;
//  565 :                 pc = (q<<1) + SH[q];
//  566 :                 goto fetch;
//  567 :               }
//  568 :

The declaration BCPLWORD n,q; declares n and q to be signed 32-bit
integers.  pc is also a 32-bit signed integer representing the
Cintcode program counter. The jump to case F_swl: was performed by
switch(B[pc++]) and so on reaching this case, pc is the subscript of
the byte following the one holding the SWL opcode. Note that B is an
array of unsigned bytes representing the entire Cintcode memory. At
this moment, pc points to a possible filler byte that ensures that the
following 16-bit values are aligned on even addresses. The switch data
is accessed by expressions like H[q] and SH[q]. In the assembly
language that follows, B, H and SH are all equal and held in r63. H
regards the Cintcode memory as an array of unsigned 16-bit integers,
and SH regards them as signed integers. The statment q = (pc+1)>>1
sets q to be the subscript of H containing n which is the number of
elements in the label vector. This is set by the statement n = H[q++]
which has the side effect of setting q to point the the next 16-bit
value. This value represents the default label as a 16-bit relative
address. After the default label are n 16-bit signed integers that are
relative addresses to the n cases of the switch. Those that do not
correspond to case labels point to the default label. The value being
switched on is held in the Cintcode register a which in the assembly
language is held in r32. The BCPL compiler has already adjusted a so
that a=0 represents the case with the lowest case constant. If a is in
range, the statement if(0<=a && a<n) q+=a+1; sets q to the subscript
of SH holdin the relative address of the required case label. But if a
is out of the range 0..n-1, q is left unchanged pointing to the
element of SH holding the default label.  The statement pc = (q<<1) +
SH[q]; adds the signed relative address to (q<<1) giving the subscript
position in B where the next Cintcode opcode will be taken.

This code works perfectly on other machines and usually on the
itanium.  But on the Itanium a problem arose when I modified the BCPL
compiler to include CASE endstreamch: in the SWITCHON statement in the
lexical analyser (lex). The constant endstreamch has value -1 and is
the smallest case constant of this switch. So after placing the next
character of input into Cintcode register a, it is incremented by an
A1 Cintcode instruction before executing the SWL instruction. With
this case present the compiler works as expected until the first time
it encounters the end-of-stream character, which is typically after
the header file (libhdr.h) has be read by the directive GET
"libhdr". The compiler then crashes with a segmentation fault
somewhere in the code dealing with SWL when it is being executed for
the first time with a(=r32) equal to zero. By removing CASE
endstreamch: and testing for endstreamch at the DEFAULT label, the
compiler works perfectly.

This fault has puzzled me for some months and I am beginning to
suspect it is a subtle bug in the code compiled by the C compiler
possible concerning the two speculative loads (ld2.s) and the related
chk.s instruction. I have annotated the compiled code as best I can in
the hope that someone will be able to confirm or deny that there is a
compiler bug.


$$1$1_0$TAG$93:  // SWL
 {   .mii  //R-Addr: 0x1c10
	ld4	r17=[r44]				//0: {321:6} 1462
	add	r25=1,r37				//0: {562:18} 1451
	cmp4.lt.unc	p8,p7=r32,r0 ;;			//0: {564:18} 2662
 }

// The ld4 r17=[r44] is a valid instruction preparing r17 for use by the
// code at label fetch. It has nothing to do with SWL
// r37 hold the Cintcode register pc, so
// r25 = pc+1
// Since a is in r32, the cmp4 instruction sets the preicates
// p8 = a<0
// p7 = a>=0

 {   .mii  //R-Addr: 0x1c20
	nop.m	0
	extr	r24=r25,1,31 ;;				//1: {562:18} 1452
	shladd	r20=r24,1,r63				//2: {563:18} 1454
 }

// r24 = (pc+1)>>1  so q is now in r24
// r63 is the m/c address of the zeroth element of B, H and SH
// r20 = &H[q], a m/c address pointing to n

 {   .mmi  //R-Addr: 0x1c30
	add	r27=1,r24 ;;				//2: {563:24} 1453
	ld2	r19=[r20]				//3: {563:18} 1455
	add	r28=r32,r27,1				//3: {564:34} 1465
 }

// r27 = q+1    q is now in r27
// r19 = H[q]   (using the q before it was incremented)  n is in r19
// r28 = q+a+1  This points to the required element of the label vector
//              provided a is in range 0..n-1 

 {   .mii  //R-Addr: 0x1c40
	nop.m	0
	shladd	r26=r27,1,r63 ;;			//3: {565:18} 1458
  (p7)	cmp4.ge	p8,p0=r32,r19				//4: {564:18} 2664
 }

// r26 = &SH[q] This points to the element after n which is the default label
// if a>=0 set p8 = a>=n ie
// p8 = a<0 || a>=n  ie =TRUE if a is out of range

 {   .mib  //R-Addr: 0x1c50
	ld2.s	r2=[r26]				//4: {565:18} 1459
	shladd	r29=r28,1,r63				//4: {565:18} 3281
// Branch taken probability 0.75
  (p8)	br.cond.dptk	.b1_495 ;;			//4: {564:18} 1464
// Block 497:  Pred: 168     Succ: 495  -G
// Freq 2.9e-02
 }

// r2 = speculative load of SH[q], the default label which will not
//      be needed if a is in range
// r29 = &SH[q+a+1], the position of the case label if a is in range
// if a is out of range, goto the default label by jumping to .b1_495

// a is now known to be in range so:

 {   .mii  //R-Addr: 0x1c60
	ld2.s	r2=[r29]				//0: {565:18} 3288
	mov	r27=r28					//0: {564:34} 3282
	mov	r26=r29 ;;				//0: {565:18} 3289
// Block 495:  Pred: 168 497     Succ: 796 809  -GO
// Freq 1.2e-01
 }

// r2 = speculative load of SH[q+a+1], rel address of the case label
//#### WHY IS THIS LOAD SPECULATIVE SINCE ITS RESULT IS NEEDED #####
//#### BUT SINCE chk.s IS GOING TO BE EXECUTED ANYWAY, IT      #####
//#### MIGHT PRODUCE SLIGHTLY MORE EFFICIENT CODE              #####
// r27 = r28 = q+a+1  This is the position of the required case label
// r26 = &SH[q+a+1]  for use at .b1_796 is speculative load failed

.b1_495: 
 {   .mii  //R-Addr: 0x1c70
	nop.m	0
	nop.i	0
	sxt2	r30=r2					//0: {565:18} 1460
 }

// r30 = sign extended speculative load of SH[q] or SH[q+a+1]
//#### r30 IS ONLY VALID IF THE SPECULATIVE LOAD WAS SUCCESSFUL #####

 {   .mmi  //R-Addr: 0x1c80
// Branch taken probability 0.05
	chk.s	r2,.b1_796 ;;				//0: {565:18} 3283
// Block 809: ltail  Pred: 495     Succ: 3  -GO
// Freq 1.1e-01
	shladd	r37=r27,1,r30				//1: {565:18} 1461
	nop.i	0
 }

// Check that the speculative load of r2 succeeded, Jump to .b1_796 if not
//############### PERHAPS THIS CHECK IS TOO LATE ####################
//#### The chk.s instruction can be obeyed at the same time as  #####
//#### the sxt2 instruction, but it is possible that it was     #####
//#### obeyed later and that the ld2.s succeeded after the sxt2 #####
//#### and before the chk.s                                     #####
//#### Why was the chk.s instruction not placed as the first    #####
//#### instruction in the .mii cluster at 0x1c70 containing     #####
//#### sxt2 as its third member.                                #####
//#### It should appear as: chk.s r2,.b1_796 ;; and I suspect   #####
//#### the ;; stop symbol is necessary                          #####

// pc = r37 = (q<<1)+SH[q] or  (q<<1)+SH[q+a+1] if the spec load worked
 
 {   .mib  //R-Addr: 0x1c90
	nop.m	0
	nop.i	0
	br.cond.sptk.many	.b1_3 ;;		//1: {565:18} 5546
// Block 167: prolog  Pred: 21     Succ: 488 699  -G
// Freq 1.2e-01
 }

// goto fetch


.b1_796: 

// This is reached if one of the speculative loads (ld2.s) failed

 {   .mmi  //R-Addr: 0x4e70
	ld2	r2=[r26] ;;				//0: {565:18} 3284
	nop.m	0
	sxt2	r30=r2 ;;				//1: {565:18} 3290
 }

// r2 = SH[q] or SH[q+a+1]   (non speculative load)
// r30 = sign entended SH[q] or SH[q+a+1]

 {   .mib  //R-Addr: 0x4e80
	shladd	r37=r27,1,r30				//2: {565:18} 5478
	nop.i	0
	br.cond.sptk.many	.b1_3 ;;		//2: {565:18} 5560

// pc = r37 = (q<<1)+SH[q] or  (q<<1)+SH[q+a+1]
// goto fetch


For complete details, see the BCPL distribution bcpl.zip (or bcpl.tgz)
available from www.cl.cam.ac.uk/users/mr10. This contains the entire
BCPL Cintcode system.  For the Itanium compilation of
BCPL/cintcode/sysc/cinterp.c look at
BCPL/cintcode/sysc/cinterp.lis. This document contains a few lines of
this file. This document is currently in bcpl.zip called
BCPL/cintcode/sysc/itaniumbug.txt

I do not believe the fault is due to random asynchronous interrupts
occurring at inconvenient places since it is a hard fault that occurs
every time that version of the BCPL compiler is run. It may however be
due to a subtle interaction with the caches and the virtual
memory. Possible there is a page fault just before the chk.s
instruction. Just guessing....


Under Open VMS on the Itanium called NETINT, the show cpu/full command
generates the following output.

NETINT=>show cpu/full

System: NETINT, HP rx2660  (1.59GHz/6.0MB)

  SMP execlet   = 3 : Enabled : Streamlined.
  Config tree   = Version 6
  Primary CPU   = 0
  HWRPB CPUs    = 1
  Page Size     = 8192
  Revision Code =
  Serial Number = DEH47130F3
  Default CPU Capabilities:
        System: QUORUM RUN
  Default Process Capabilities:
        System: QUORUM RUN

CPU 0    State: RUN                CPUDB: 8801E000     Handle: 00005D70
         Owner: 000004C8         Current: 000004C8     Partition 0 (NETINT)
        ChgCnt:        1           State: Present, Primary, Reassignable
       Process: MRICH177             PID: 001C2DDF
  Capabilities:
        System: PRIMARY QUORUM RUN RAD0
  Slot Context: 9017D000
     CPU     -  State..........: RC, PA, PP, CV, PV, PMV, PL
                Type...........: Itanium Major = 32,  Minor = 0
                Speed..........: 1595 Mhz
                LID............: 00000000
                Variation......: IEEE FP, Primary Eligible
                Serial Number..: 000039017F7B5ACD
                Revision.......:
                Halt Request...: 0
                Software Comp..: 7.0
     PALCODE -  Revision Code..: 1.1
                Compatibility..: 0
                Max Shared CPUs: 0
  Bindings:
     NETACP           PID = 00000416  Reason: PRIMARY Capability
  Fastpath:
        PKB0
        PKA0
        EWA0
        EWB0
        BG0
  Features:
     Autostart - Enabled.
     Fastpath  - Selection enabled as Preferred CPU.
NETINT=>


For additional evidence I include the relevant portion of the
compiler's disassembly of the object module.


                                                $$1$1_0$TAG$93:
C21C0209.00420094 09901010.58008801  00001C10:  { .mii
                       008082C00440         0:    M1               ld4         r17 = [r44]
                       010802502640         1:    A4               add         ai = 0001, r37
                       018438041200         2:    A6               cmp4.lt.unc p8, p7 = r32, r0 ;;                          }

8041F982.80293C64 19800001.00000002  00001C20:  { .mii
                       000008000000         0:    M48              nop.m       000000
                       00A4F1906600         1:    I11              extr        r24 = ai, 01, 1F ;;
                       010083F30500         2:    A2               shladd      r20 = r24, 1, r63                            }

8004DA03.80201050 01302100.3004D80A  00001C30:  { .mmi
                       0108018026C0         0:    A4               add         r27 = 0001, r24 ;;
                       0080414004C0         1:    M1               ld2         r19 = [r20]
                       010009B40700         2:    A1               add         r28 = r32, r27, 1                            }

C2209A00.03C020FC D9A00001.00000002  00001C40:  { .mii
                       000008000000         0:    M48              nop.m       000000
                       010083F36680         1:    A2               shladd      r26 = r27, 1, r63 ;;
                       018441340007         2:    A6          (p7) cmp4.lt     p0, p8 = r32, r19                            }

42000020.044020FC E1D01028.34001011  00001C50:  { .mib
                       008141A00080         0:    M1               ld2.s       r2 = [r26]
                       010083F38740         1:    A2               shladd      r29 = r28, 1, r63
                       008400004008         2:    B1          (p8) br.cond.dptk.few $+0000020 ;;                            }


Analyze/Disassemble Object File                  5-JUN-2013 10:49:44.45                                                 Page 47     
LDA19:[MRICH177.DISTRIBUTION.BCPL.CINTCODE.SYSC]CINTERP.OBJ;167
ANALYZ I01-51

8400E803.40420070 01B01028.3A001001  00001C60:  { .mii
                       008141D00080         0:    M1               ld2.s       r2 = [r29]
                       010801C006C0         1:    A4               mov         r27 = r28
                       010801D00680         2:    A4               mov         r26 = r29 ;;                                 }

00541003.C0000200 00000001.00000000  00001C70:  { .mii
                       000008000000         0:    M48              nop.m       000000
                       000008000000         1:    I18              nop.i       000000
                       0000A8200780         2:    I29              sxt2        r30 = r2                                     }

00040000.00402078 DA500440.0C08F80A  00001C80:  { .mmi
                       0022006047C0         0:    M20              chk.s.m     r2, 00031F0 ;;
                       010081E36940         1:    A2               shladd      r37 = r27, 1, r30
                       000008000000         2:    I18              nop.i       000000                                       }

48FFE498.00000200 00000001.00000011  00001C90:  { .mib
                       000008000000         0:    M48              nop.m       000000
                       000008000000         1:    I18              nop.i       000000
                       0091FFC93000         2:    B1               br.many     $-0001B70 ;;                                 }



Plus also the disassembly at label


00541003.C0000200 00001008.3400100B  00004E70:  { .mmi
                       008041A00080         0:    M1               ld2         r2 = [r26] ;;
                       000008000000         1:    M48              nop.m       000000
                       0000A8200780         2:    I29              sxt2        r30 = r2 ;;                                  }

48FFB2A8.00000200 00002010.3C6D2811  00004E80:  { .mib
                       010081E36940         0:    A2               shladd      r37 = r27, 1, r30
                       000008000000         1:    I18              nop.i       000000
                       0091FF655000         2:    B1               br.many     $-0004D60 ;;                                 }


I have tried hard to construct a short program that exhibits the same
fault but have failed. My closest attempt is the following C program,
given below. At least its use of ld2.s and chk.s are similar and I
believe illustrate the same bug. Unfortunately the effect of the
speculative load ld2.s is dependent on what else is running on the
machine at the time. The program below compiles as runs correctly.

#include <stdio.h>

#define BCPLWORD int
#define SHP (short *)
#define SH (SHP W)
#define HP (unsigned short *)
#define H (HP W)
#define B ((unsigned char *)W)

extern BCPLWORD tst(BCPLWORD, BCPLWORD, BCPLWORD*);

int main() {
  BCPLWORD W[10000000];
  BCPLWORD a, pc, tab;

  pc = 51621;

  //skip over possible fill, n and the default label
  tab = ((pc+1)>>1)+2;

  // Fill in n, the defauilt label and the case labels
  SH[tab-2] = 128;   // the table size
  SH[tab-1] = -2000; // default rel address
  for(a=0; a<128; a++) SH[tab+a] = -(1000+a);

  for(a=0; a<100; a++) tst(a,pc,W);

  return 0;
}

BCPLWORD tst(BCPLWORD a, BCPLWORD pc, BCPLWORD*W) {
  switch(a) {
    default: //break;

    case 93:
    { BCPLWORD n,q;
      q = (pc+1)>>1;
      n = H[q++];
      if(0<=a && a<n) q += a+1;
      pc = (q<<1) + SH[q];
printf("case 93: a=%d n=%d q=%d SH[q]=%d pc=%d\n", a, n, q, SH[q], pc);
      break;
    }
  }

  return pc;
}





Any comments/help would be welcome.

Martin Richards
mr@cl.cam.ac.uk
mrich177@ford.com
www.cl.cam.ac.uk/users/mr10
6 June 2013
